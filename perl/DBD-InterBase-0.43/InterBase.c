/*
 * This file was generated automatically by xsubpp version 1.9508 from the
 * contents of InterBase.xs. Do not edit this file, edit InterBase.xs instead.
 *
 *	ANY CHANGES MADE HERE WILL BE LOST!
 *
 */

#line 1 "InterBase.xs"
/*
   $Id: InterBase.xs,v 1.43 2003/12/06 11:04:10 edpratomo Exp $

   Copyright (c) 1999-2003  Edwin Pratomo
   Portions Copyright (c) 2001-2003  Daniel Ritz

   You may distribute under the terms of either the GNU General Public
   License or the Artistic License, as specified in the Perl README file,
   with the exception that it cannot be placed on a CD-ROM or similar media
   for commercial distribution without the prior approval of the author.

*/

#include "InterBase.h"

/* callback function for events, called by InterBase */
isc_callback _async_callback(IB_EVENT ISC_FAR *ev, short length, char ISC_FAR *updated)
{
#if defined(USE_THREADS) || defined(USE_ITHREADS) || defined(MULTIPLICITY)
    /* save context, set context from dbh */
    void *context = PERL_GET_CONTEXT;
    PERL_SET_CONTEXT(ev->dbh->context);
    {
#else
    void *context = PERL_GET_CONTEXT;
    PerlInterpreter *cb_perl = perl_alloc();
    PERL_SET_CONTEXT(cb_perl);
    {
#endif
        dSP;
        char ISC_FAR *result = ev->result_buffer;

        ENTER;
        SAVETMPS;

        PUSHMARK(SP);
        PUTBACK;

        perl_call_sv(ev->perl_cb, G_VOID);

        FREETMPS;
        LEAVE;

        /* Copy the updated buffer to the result buffer */
        while (length--)
            *result++ = *updated++;

        ev->cb_called = 1;
#if defined(USE_THREADS) || defined(USE_ITHREADS) || defined(MULTIPLICITY)
    }

    /* restore old context*/
    PERL_SET_CONTEXT(context);
#else
    }
    PERL_SET_CONTEXT(context);
    perl_free(cb_perl);
#endif

    return (0);
}

DBISTATE_DECLARE;

#line 75 "InterBase.c"

/* INCLUDE:  Including 'InterBase.xsi' from 'InterBase.xs' */

#include "Driver_xst.h"
#ifdef dbd_discon_all
#define XSubPPtmpAAAA 1

XS(XS_DBD__InterBase__dr_discon_all_); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__InterBase__dr_discon_all_)
{
    dXSARGS;
    dXSI32;
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(drh)", GvNAME(CvGV(cv)));
    {
	SV *	drh = ST(0);
#line 42 "InterBase.xsi"
    D_imp_drh(drh);
    if (0) ix = ix;	/* avoid unused variable warning */
    ST(0) = dbd_discon_all(drh, imp_drh) ? &sv_yes : &sv_no;
#line 96 "InterBase.c"
    }
    XSRETURN(1);
}

#endif /* dbd_discon_all */
#ifdef dbd_dr_data_sources
#define XSubPPtmpAAAB 1

XS(XS_DBD__InterBase__dr_data_sources); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__InterBase__dr_data_sources)
{
    dXSARGS;
    if (items < 1 || items > 2)
	Perl_croak(aTHX_ "Usage: DBD::InterBase::dr::data_sources(drh, attr = Nullsv)");
    SP -= items;
    {
	SV *	drh = ST(0);
	SV *	attr;

	if (items < 2)
	    attr = Nullsv;
	else {
	    attr = ST(1);
	}
#line 56 "InterBase.xsi"
    {
	D_imp_drh(drh);
	AV *av = dbd_dr_data_sources(drh, imp_drh, attr);
	if (av) {
	    int i;
	    int n = AvFILL(av)+1;
	    EXTEND(sp, n);
	    for (i = 0; i < n; ++i) {
		PUSHs(AvARRAY(av)[i]);
	    }
	}
    }
#line 134 "InterBase.c"
	PUTBACK;
	return;
    }
}

#endif
XS(XS_DBD__InterBase__db__login); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__InterBase__db__login)
{
    dXSARGS;
    if (items < 4 || items > 5)
	Perl_croak(aTHX_ "Usage: DBD::InterBase::db::_login(dbh, dbname, username, password, attribs=Nullsv)");
    {
	SV *	dbh = ST(0);
	char *	dbname = (char *)SvPV_nolen(ST(1));
	SV *	username = ST(2);
	SV *	password = ST(3);
	SV *	attribs;

	if (items < 5)
	    attribs = Nullsv;
	else {
	    attribs = ST(4);
	}
#line 86 "InterBase.xsi"
    {
    STRLEN lna;
    D_imp_dbh(dbh);
    char *u = (SvOK(username)) ? SvPV(username,lna) : "";
    char *p = (SvOK(password)) ? SvPV(password,lna) : "";
#ifdef dbd_db_login6
    ST(0) = dbd_db_login6(dbh, imp_dbh, dbname, u, p, attribs) ? &sv_yes : &sv_no;
#else
    ST(0) = dbd_db_login( dbh, imp_dbh, dbname, u, p) ? &sv_yes : &sv_no;
#endif
    }
#line 171 "InterBase.c"
    }
    XSRETURN(1);
}

XS(XS_DBD__InterBase__db_selectall_arrayref); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__InterBase__db_selectall_arrayref)
{
    dXSARGS;
    {
#line 102 "InterBase.xsi"
    SV *sth;
    SV **maxrows_svp;
    SV **tmp_svp;
    SV *attr = &PL_sv_undef;
    imp_sth_t *imp_sth;
#line 187 "InterBase.c"
#line 108 "InterBase.xsi"
    if (items > 2) {
	attr = ST(2);
	if (SvROK(attr) &&
		(DBD_ATTRIB_TRUE(attr,"Slice",5,tmp_svp) || DBD_ATTRIB_TRUE(attr,"Columns",7,tmp_svp))
	) {
	    /* fallback to perl implementation */
	    ST(0) = dbixst_bounce_method("DBD::InterBase::db::SUPER::selectall_arrayref", items);
	    XSRETURN(1);
	}
    }
    /* --- prepare --- */
    if (SvROK(ST(1))) {
	sth = ST(1);
    }
    else {
	sth = dbixst_bounce_method("prepare", 3);
	if (!SvROK(sth))
	    XSRETURN_UNDEF;
    }
    imp_sth = (imp_sth_t*)(DBIh_COM(sth));
    /* --- bind_param --- */
    if (items > 3) {    /* need to bind params before execute */
        if (!dbdxst_bind_params(sth, imp_sth, items-2, ax+2) ) {
            XSRETURN_UNDEF;
        }
    }
    /* --- execute --- */
    DBIc_ROW_COUNT(imp_sth) = 0;
    if ( dbd_st_execute(sth, imp_sth) <= -2 ) { /* -2 == error */
        XSRETURN_UNDEF;
    }
    /* --- fetchall --- */
    maxrows_svp = DBD_ATTRIB_GET_SVP(attr, "MaxRows", 7);
    ST(0) = dbdxst_fetchall_arrayref(sth, &PL_sv_undef, (maxrows_svp) ? *maxrows_svp : &PL_sv_undef);
#line 223 "InterBase.c"
    }
    XSRETURN(1);
}

XS(XS_DBD__InterBase__db_selectrow_arrayref); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__InterBase__db_selectrow_arrayref)
{
    dXSARGS;
    dXSI32;
   PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 149 "InterBase.xsi"
    imp_sth_t *imp_sth;
    SV *sth;
    AV *row_av;
#line 240 "InterBase.c"
#line 153 "InterBase.xsi"
    if (SvROK(ST(1))) {
	sth = ST(1);
    }
    else {
	/* --- prepare --- */
	sth = dbixst_bounce_method("prepare", 3);
	if (!SvROK(sth))
	    XSRETURN_UNDEF;
    }
    imp_sth = (imp_sth_t*)(DBIh_COM(sth));
    /* --- bind_param --- */
    if (items > 3) {	/* need to bind params before execute */
	if (!dbdxst_bind_params(sth, imp_sth, items-2, ax+2) ) {
	    XSRETURN_UNDEF;
	}
    }
    /* --- execute --- */
    DBIc_ROW_COUNT(imp_sth) = 0;
    if ( dbd_st_execute(sth, imp_sth) <= -2 ) {	/* -2 == error */
        XSRETURN_UNDEF;
    }
    /* --- fetchrow_arrayref --- */
    row_av = dbd_st_fetch(sth, imp_sth);
    if (!row_av) {
	if (GIMME == G_SCALAR)
	    PUSHs(&PL_sv_undef);
    }
    else if (ix == 1) { /* selectrow_array */
	int i;
	int num_fields = AvFILL(row_av)+1;
	if (GIMME == G_SCALAR)
	    num_fields = 1; /* return just first field */
	EXTEND(sp, num_fields);
	for(i=0; i < num_fields; ++i) {
	    PUSHs(AvARRAY(row_av)[i]);
	}
    }
    else {
	PUSHs( sv_2mortal(newRV((SV *)row_av)) );
    }
    /* --- finish --- */
#ifdef dbd_st_finish3
    dbd_st_finish3(sth, imp_sth, 0);
#else
    dbd_st_finish(sth, imp_sth);
#endif
#line 288 "InterBase.c"
	PUTBACK;
	return;
    }
}

#ifdef dbd_db_do4 /* deebeedee-deebee-doo, deebee-doobee-dah? */
#define XSubPPtmpAAAC 1

XS(XS_DBD__InterBase__db_do); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__InterBase__db_do)
{
    dXSARGS;
    if (items < 2 || items > 3)
	Perl_croak(aTHX_ "Usage: DBD::InterBase::db::do(dbh, statement, params = Nullsv)");
    {
	SV *	dbh = ST(0);
	char *	statement = (char *)SvPV_nolen(ST(1));
	SV *	params;

	if (items < 3)
	    params = Nullsv;
	else {
	    params = ST(2);
	}
#line 209 "InterBase.xsi"
    D_imp_dbh(dbh);
    ST(0) = dbd_db_do4(dbh, imp_dbh, statement, params) ? &sv_yes : &sv_no;
#line 316 "InterBase.c"
    }
    XSRETURN(1);
}

#endif
XS(XS_DBD__InterBase__db_commit); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__InterBase__db_commit)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: DBD::InterBase::db::commit(dbh)");
    {
	SV *	dbh = ST(0);
#line 219 "InterBase.xsi"
    D_imp_dbh(dbh);
    if (DBIc_has(imp_dbh,DBIcf_AutoCommit) && DBIc_WARN(imp_dbh))
	warn("commit ineffective with AutoCommit enabled");
    ST(0) = dbd_db_commit(dbh, imp_dbh) ? &sv_yes : &sv_no;
#line 335 "InterBase.c"
    }
    XSRETURN(1);
}

XS(XS_DBD__InterBase__db_rollback); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__InterBase__db_rollback)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: DBD::InterBase::db::rollback(dbh)");
    {
	SV *	dbh = ST(0);
#line 229 "InterBase.xsi"
    D_imp_dbh(dbh);
    if (DBIc_has(imp_dbh,DBIcf_AutoCommit) && DBIc_WARN(imp_dbh))
	warn("rollback ineffective with AutoCommit enabled");
    ST(0) = dbd_db_rollback(dbh, imp_dbh) ? &sv_yes : &sv_no;
#line 353 "InterBase.c"
    }
    XSRETURN(1);
}

XS(XS_DBD__InterBase__db_disconnect); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__InterBase__db_disconnect)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: DBD::InterBase::db::disconnect(dbh)");
    {
	SV *	dbh = ST(0);
#line 239 "InterBase.xsi"
    D_imp_dbh(dbh);
    if ( !DBIc_ACTIVE(imp_dbh) ) {
	XSRETURN_YES;
    }
    /* pre-disconnect checks and tidy-ups */
    if (DBIc_CACHED_KIDS(imp_dbh)) {
	SvREFCNT_dec(DBIc_CACHED_KIDS(imp_dbh));      /* cast them to the winds	*/
	DBIc_CACHED_KIDS(imp_dbh) = Nullhv;
    }
    /* Check for disconnect() being called whilst refs to cursors	*/
    /* still exists. This possibly needs some more thought.		*/
    if (DBIc_ACTIVE_KIDS(imp_dbh) && DBIc_WARN(imp_dbh) && !dirty) {
	STRLEN lna;
	char *plural = (DBIc_ACTIVE_KIDS(imp_dbh)==1) ? "" : "s";
	warn("%s->disconnect invalidates %d active statement handle%s %s",
	    SvPV(dbh,lna), (int)DBIc_ACTIVE_KIDS(imp_dbh), plural,
	    "(either destroy statement handles or call finish on them before disconnecting)");
    }
    ST(0) = dbd_db_disconnect(dbh, imp_dbh) ? &sv_yes : &sv_no;
    DBIc_ACTIVE_off(imp_dbh);	/* ensure it's off, regardless */
#line 387 "InterBase.c"
    }
    XSRETURN(1);
}

XS(XS_DBD__InterBase__db_STORE); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__InterBase__db_STORE)
{
    dXSARGS;
    if (items != 3)
	Perl_croak(aTHX_ "Usage: DBD::InterBase::db::STORE(dbh, keysv, valuesv)");
    {
	SV *	dbh = ST(0);
	SV *	keysv = ST(1);
	SV *	valuesv = ST(2);
#line 267 "InterBase.xsi"
    D_imp_dbh(dbh);
    if (SvGMAGICAL(valuesv))
	mg_get(valuesv);
    ST(0) = &sv_yes;
    if (!dbd_db_STORE_attrib(dbh, imp_dbh, keysv, valuesv))
	if (!DBIc_DBISTATE(imp_dbh)->set_attr(dbh, keysv, valuesv))
	    ST(0) = &sv_no;
#line 410 "InterBase.c"
    }
    XSRETURN(1);
}

XS(XS_DBD__InterBase__db_FETCH); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__InterBase__db_FETCH)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: DBD::InterBase::db::FETCH(dbh, keysv)");
    {
	SV *	dbh = ST(0);
	SV *	keysv = ST(1);
#line 281 "InterBase.xsi"
    D_imp_dbh(dbh);
    SV *valuesv = dbd_db_FETCH_attrib(dbh, imp_dbh, keysv);
    if (!valuesv)
	valuesv = DBIc_DBISTATE(imp_dbh)->get_attr(dbh, keysv);
    ST(0) = valuesv;	/* dbd_db_FETCH_attrib did sv_2mortal	*/
#line 430 "InterBase.c"
    }
    XSRETURN(1);
}

XS(XS_DBD__InterBase__db_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__InterBase__db_DESTROY)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: DBD::InterBase::db::DESTROY(dbh)");
    SP -= items;
    {
	SV *	dbh = ST(0);
#line 292 "InterBase.xsi"
    D_imp_dbh(dbh);
    ST(0) = &sv_yes;
    if (!DBIc_IMPSET(imp_dbh)) {	/* was never fully set up	*/
	STRLEN lna;
	if (DBIc_WARN(imp_dbh) && !dirty && DBIc_DBISTATE(imp_dbh)->debug >= 2)
	     PerlIO_printf(DBILOGFP,
		"         DESTROY for %s ignored - handle not initialised\n",
			SvPV(dbh,lna));
    }
    else {
	/* pre-disconnect checks and tidy-ups */
	if (DBIc_CACHED_KIDS(imp_dbh)) {
	    SvREFCNT_dec(DBIc_CACHED_KIDS(imp_dbh));  /* cast them to the winds	*/
	    DBIc_CACHED_KIDS(imp_dbh) = Nullhv;
	}
        if (DBIc_IADESTROY(imp_dbh)) {		  /* want's ineffective destroy	*/
            DBIc_ACTIVE_off(imp_dbh);
        }
	if (DBIc_ACTIVE(imp_dbh)) {
	    /* The application has not explicitly disconnected. That's bad.	*/
	    /* To ensure integrity we *must* issue a rollback. This will be	*/
	    /* harmless	if the application has issued a commit. If it hasn't	*/
	    /* then it'll ensure integrity. Consider a Ctrl-C killing perl	*/
	    /* between two statements that must be executed as a transaction.	*/
	    /* Perl will call DESTROY on the dbh and, if we don't rollback,	*/
	    /* the server may automatically commit! Bham! Corrupt database!	*/
	    if (!DBIc_has(imp_dbh,DBIcf_AutoCommit)) {
		if (DBIc_WARN(imp_dbh) && (!dirty || DBIc_DBISTATE(imp_dbh)->debug >= 3))
		     warn("Issuing rollback() for database handle being DESTROY'd without explicit disconnect()");
		dbd_db_rollback(dbh, imp_dbh);			/* ROLLBACK! */
	    }
	    dbd_db_disconnect(dbh, imp_dbh);
	    DBIc_ACTIVE_off(imp_dbh);	/* ensure it's off, regardless */
	}
	dbd_db_destroy(dbh, imp_dbh);
    }
#line 481 "InterBase.c"
	PUTBACK;
	return;
    }
}

XS(XS_DBD__InterBase__st__prepare); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__InterBase__st__prepare)
{
    dXSARGS;
    if (items < 2 || items > 3)
	Perl_croak(aTHX_ "Usage: DBD::InterBase::st::_prepare(sth, statement, attribs=Nullsv)");
    {
	SV *	sth = ST(0);
	char *	statement = (char *)SvPV_nolen(ST(1));
	SV *	attribs;

	if (items < 3)
	    attribs = Nullsv;
	else {
	    attribs = ST(2);
	}
#line 344 "InterBase.xsi"
    {
    D_imp_sth(sth);
    DBD_ATTRIBS_CHECK("_prepare", sth, attribs);
    ST(0) = dbd_st_prepare(sth, imp_sth, statement, attribs) ? &sv_yes : &sv_no;
    }
#line 509 "InterBase.c"
    }
    XSRETURN(1);
}

#ifdef dbd_st_rows
#define XSubPPtmpAAAD 1

XS(XS_DBD__InterBase__st_rows); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__InterBase__st_rows)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: DBD::InterBase::st::rows(sth)");
    {
	SV *	sth = ST(0);
#line 357 "InterBase.xsi"
    D_imp_sth(sth);
    XST_mIV(0, dbd_st_rows(sth, imp_sth));
#line 528 "InterBase.c"
    }
    XSRETURN(1);
}

#endif /* dbd_st_rows */
XS(XS_DBD__InterBase__st_bind_param); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__InterBase__st_bind_param)
{
    dXSARGS;
    if (items < 3 || items > 4)
	Perl_croak(aTHX_ "Usage: DBD::InterBase::st::bind_param(sth, param, value, attribs=Nullsv)");
    {
	SV *	sth = ST(0);
	SV *	param = ST(1);
	SV *	value = ST(2);
	SV *	attribs;

	if (items < 4)
	    attribs = Nullsv;
	else {
	    attribs = ST(3);
	}
#line 370 "InterBase.xsi"
    {
    IV sql_type = 0;
    D_imp_sth(sth);
    if (SvGMAGICAL(value))
	mg_get(value);
    if (attribs) {
	if (SvNIOK(attribs)) {
	    sql_type = SvIV(attribs);
	    attribs = Nullsv;
	}
	else {
	    SV **svp;
	    DBD_ATTRIBS_CHECK("bind_param", sth, attribs);
	    /* XXX we should perhaps complain if TYPE is not SvNIOK */
	    DBD_ATTRIB_GET_IV(attribs, "TYPE",4, svp, sql_type);
	}
    }
    ST(0) = dbd_bind_ph(sth, imp_sth, param, value, sql_type, attribs, FALSE, 0)
		? &sv_yes : &sv_no;
    }
#line 572 "InterBase.c"
    }
    XSRETURN(1);
}

XS(XS_DBD__InterBase__st_bind_param_inout); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__InterBase__st_bind_param_inout)
{
    dXSARGS;
    if (items < 4 || items > 5)
	Perl_croak(aTHX_ "Usage: DBD::InterBase::st::bind_param_inout(sth, param, value_ref, maxlen, attribs=Nullsv)");
    {
	SV *	sth = ST(0);
	SV *	param = ST(1);
	SV *	value_ref = ST(2);
	IV	maxlen = (IV)SvIV(ST(3));
	SV *	attribs;

	if (items < 5)
	    attribs = Nullsv;
	else {
	    attribs = ST(4);
	}
#line 400 "InterBase.xsi"
    {
    IV sql_type = 0;
    D_imp_sth(sth);
    SV *value;
    if (!SvROK(value_ref) || SvTYPE(SvRV(value_ref)) > SVt_PVMG)
	croak("bind_param_inout needs a reference to a scalar value");
    value = SvRV(value_ref);
    if (SvREADONLY(value))
	croak("Modification of a read-only value attempted");
    if (SvGMAGICAL(value))
	mg_get(value);
    if (attribs) {
	if (SvNIOK(attribs)) {
	    sql_type = SvIV(attribs);
	    attribs = Nullsv;
	}
	else {
	    SV **svp;
	    DBD_ATTRIBS_CHECK("bind_param", sth, attribs);
	    DBD_ATTRIB_GET_IV(attribs, "TYPE",4, svp, sql_type);
	}
    }
    ST(0) = dbd_bind_ph(sth, imp_sth, param, value, sql_type, attribs, TRUE, maxlen)
		? &sv_yes : &sv_no;
    }
#line 621 "InterBase.c"
    }
    XSRETURN(1);
}

XS(XS_DBD__InterBase__st_execute); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__InterBase__st_execute)
{
    dXSARGS;
    if (items < 1)
	Perl_croak(aTHX_ "Usage: DBD::InterBase::st::execute(sth, ...)");
    {
	SV *	sth = ST(0);
#line 431 "InterBase.xsi"
    D_imp_sth(sth);
    int retval;
    if (items > 1) {	/* need to bind params */
	if (!dbdxst_bind_params(sth, imp_sth, items, ax) ) {
	    XSRETURN_UNDEF;
	}
    }
    /* XXX this code is duplicated in selectrow_arrayref above	*/
    if (DBIc_ROW_COUNT(imp_sth) > 0) /* reset for re-execute */
	DBIc_ROW_COUNT(imp_sth) = 0;
    retval = dbd_st_execute(sth, imp_sth);
    /* remember that dbd_st_execute must return <= -2 for error	*/
    if (retval == 0)		/* ok with no rows affected	*/
	XST_mPV(0, "0E0");	/* (true but zero)		*/
    else if (retval < -1)	/* -1 == unknown number of rows	*/
	XST_mUNDEF(0);		/* <= -2 means error   		*/
    else
	XST_mIV(0, retval);	/* typically 1, rowcount or -1	*/
#line 653 "InterBase.c"
    }
    XSRETURN(1);
}

XS(XS_DBD__InterBase__st_fetchrow_arrayref); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__InterBase__st_fetchrow_arrayref)
{
    dXSARGS;
    dXSI32;
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(sth)", GvNAME(CvGV(cv)));
    {
	SV *	sth = ST(0);
#line 457 "InterBase.xsi"
    D_imp_sth(sth);
    AV *av;
    if (0) ix = ix;	/* avoid unused variable warning */
    av = dbd_st_fetch(sth, imp_sth);
    ST(0) = (av) ? sv_2mortal(newRV((SV *)av)) : &PL_sv_undef;
#line 673 "InterBase.c"
    }
    XSRETURN(1);
}

XS(XS_DBD__InterBase__st_fetchrow_array); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__InterBase__st_fetchrow_array)
{
    dXSARGS;
    dXSI32;
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(sth)", GvNAME(CvGV(cv)));
    SP -= items;
    {
	SV *	sth = ST(0);
#line 470 "InterBase.xsi"
    D_imp_sth(sth);
    AV *av;
    av = dbd_st_fetch(sth, imp_sth);
    if (av) {
	int i;
	int num_fields = AvFILL(av)+1;
	EXTEND(sp, num_fields);
	for(i=0; i < num_fields; ++i) {
	    PUSHs(AvARRAY(av)[i]);
	}
	if (0) ix = ix;	/* avoid unused variable warning */
    }
#line 701 "InterBase.c"
	PUTBACK;
	return;
    }
}

XS(XS_DBD__InterBase__st_fetchall_arrayref); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__InterBase__st_fetchall_arrayref)
{
    dXSARGS;
    if (items < 1 || items > 3)
	Perl_croak(aTHX_ "Usage: DBD::InterBase::st::fetchall_arrayref(sth, slice=&PL_sv_undef, batch_row_count=&PL_sv_undef)");
    {
	SV *	sth = ST(0);
	SV *	slice;
	SV *	batch_row_count;

	if (items < 2)
	    slice = &PL_sv_undef;
	else {
	    slice = ST(1);
	}

	if (items < 3)
	    batch_row_count = &PL_sv_undef;
	else {
	    batch_row_count = ST(2);
	}
#line 490 "InterBase.xsi"
    if (SvOK(slice)) {  /* fallback to perl implementation */
        ST(0) = dbixst_bounce_method("DBD::InterBase::st::SUPER::fetchall_arrayref", 3);
    }
    else {
	ST(0) = dbdxst_fetchall_arrayref(sth, slice, batch_row_count);
    }
#line 736 "InterBase.c"
    }
    XSRETURN(1);
}

XS(XS_DBD__InterBase__st_finish); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__InterBase__st_finish)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: DBD::InterBase::st::finish(sth)");
    {
	SV *	sth = ST(0);
#line 502 "InterBase.xsi"
    D_imp_sth(sth);
    D_imp_dbh_from_sth;
    if (!DBIc_ACTIVE(imp_sth)) {
	/* No active statement to finish	*/
	XSRETURN_YES;
    }
    if (!DBIc_ACTIVE(imp_dbh)) {
	/* Either an explicit disconnect() or global destruction	*/
	/* has disconnected us from the database. Finish is meaningless	*/
	DBIc_ACTIVE_off(imp_sth);
	XSRETURN_YES;
    }
#ifdef dbd_st_finish3
    ST(0) = dbd_st_finish3(sth, imp_sth, 0) ? &sv_yes : &sv_no;
#else
    ST(0) = dbd_st_finish(sth, imp_sth) ? &sv_yes : &sv_no;
#endif
#line 767 "InterBase.c"
    }
    XSRETURN(1);
}

XS(XS_DBD__InterBase__st_blob_read); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__InterBase__st_blob_read)
{
    dXSARGS;
    if (items < 4 || items > 6)
	Perl_croak(aTHX_ "Usage: DBD::InterBase::st::blob_read(sth, field, offset, len, destrv=Nullsv, destoffset=0)");
    {
	SV *	sth = ST(0);
	int	field = (int)SvIV(ST(1));
	long	offset = (long)SvIV(ST(2));
	long	len = (long)SvIV(ST(3));
	SV *	destrv;
	long	destoffset;

	if (items < 5)
	    destrv = Nullsv;
	else {
	    destrv = ST(4);
	}

	if (items < 6)
	    destoffset = 0;
	else {
	    destoffset = (long)SvIV(ST(5));
	}
#line 530 "InterBase.xsi"
    {
    D_imp_sth(sth);
    if (!destrv)
        destrv = sv_2mortal(newRV(sv_2mortal(newSV(0))));
    if (dbd_st_blob_read(sth, imp_sth, field, offset, len, destrv, destoffset))
         ST(0) = SvRV(destrv);
    else ST(0) = &PL_sv_undef;
    }
#line 806 "InterBase.c"
    }
    XSRETURN(1);
}

XS(XS_DBD__InterBase__st_STORE); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__InterBase__st_STORE)
{
    dXSARGS;
    if (items != 3)
	Perl_croak(aTHX_ "Usage: DBD::InterBase::st::STORE(sth, keysv, valuesv)");
    {
	SV *	sth = ST(0);
	SV *	keysv = ST(1);
	SV *	valuesv = ST(2);
#line 546 "InterBase.xsi"
    D_imp_sth(sth);
    if (SvGMAGICAL(valuesv))
	mg_get(valuesv);
    ST(0) = &sv_yes;
    if (!dbd_st_STORE_attrib(sth, imp_sth, keysv, valuesv))
	if (!DBIc_DBISTATE(imp_sth)->set_attr(sth, keysv, valuesv))
	    ST(0) = &sv_no;
#line 829 "InterBase.c"
    }
    XSRETURN(1);
}

XS(XS_DBD__InterBase__st_FETCH_attrib); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__InterBase__st_FETCH_attrib)
{
    dXSARGS;
    dXSI32;
    if (items != 2)
       Perl_croak(aTHX_ "Usage: %s(sth, keysv)", GvNAME(CvGV(cv)));
    {
	SV *	sth = ST(0);
	SV *	keysv = ST(1);
#line 563 "InterBase.xsi"
    D_imp_sth(sth);
    SV *valuesv;
    if (0) ix = ix;	/* avoid unused variable warning */
    valuesv = dbd_st_FETCH_attrib(sth, imp_sth, keysv);
    if (!valuesv)
	valuesv = DBIc_DBISTATE(imp_sth)->get_attr(sth, keysv);
    ST(0) = valuesv;	/* dbd_st_FETCH_attrib did sv_2mortal	*/
#line 852 "InterBase.c"
    }
    XSRETURN(1);
}

XS(XS_DBD__InterBase__st_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__InterBase__st_DESTROY)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: DBD::InterBase::st::DESTROY(sth)");
    SP -= items;
    {
	SV *	sth = ST(0);
#line 576 "InterBase.xsi"
    D_imp_sth(sth);
    ST(0) = &sv_yes;
    if (!DBIc_IMPSET(imp_sth)) {	/* was never fully set up	*/
	STRLEN lna;
	if (DBIc_WARN(imp_sth) && !dirty && DBIc_DBISTATE(imp_sth)->debug >= 2)
	     PerlIO_printf(DBILOGFP,
		"Statement handle %s DESTROY ignored - never set up\n",
		    SvPV(sth,lna));
    }
    else {
        if (DBIc_IADESTROY(imp_sth)) { /* want's ineffective destroy    */
            DBIc_ACTIVE_off(imp_sth);
        }
	if (DBIc_ACTIVE(imp_sth)) {
	    D_imp_dbh_from_sth;
	    if (DBIc_ACTIVE(imp_dbh)) {
#ifdef dbd_st_finish3
	    dbd_st_finish3(sth, imp_sth, 1);
#else
	    dbd_st_finish(sth, imp_sth);
#endif
	    }
	    else {
		DBIc_ACTIVE_off(imp_sth);
	    }
	}
	dbd_st_destroy(sth, imp_sth);
    }
#line 895 "InterBase.c"
	PUTBACK;
	return;
    }
}


/* INCLUDE: Returning to 'InterBase.xs' from 'InterBase.xsi' */

XS(XS_DBD__InterBase__db__do); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__InterBase__db__do)
{
    dXSARGS;
    if (items < 2 || items > 3)
	Perl_croak(aTHX_ "Usage: DBD::InterBase::db::_do(dbh, statement, attr=Nullsv)");
    {
	SV *	dbh = ST(0);
	SV *	statement = ST(1);
	SV *	attr;

	if (items < 3)
	    attr = Nullsv;
	else {
	    attr = ST(2);
	}
#line 78 "InterBase.xs"
{
    D_imp_dbh(dbh);
    ISC_STATUS status[ISC_STATUS_LENGTH]; /* isc api status vector    */
    STRLEN     slen;
    int        retval;
    char       *sbuf = SvPV(statement, slen);

    DBI_TRACE(1, (DBILOGFP, "db::_do\n"
                            "Executing : %s\n", sbuf));

    /* we need an open transaction */
    if (!imp_dbh->tr)
    {
        DBI_TRACE(1, (DBILOGFP, "starting new transaction..\n"));

        if (!ib_start_transaction(dbh, imp_dbh))
        {
            retval = -2;
            XST_mUNDEF(0);      /* <= -2 means error        */
            return;
        }

        DBI_TRACE(1, (DBILOGFP, "new transaction started.\n"));
    }

    /* only execute_immediate statment if NOT in soft commit mode */
    if (!(imp_dbh->soft_commit))
    {
        isc_dsql_execute_immediate(status, &(imp_dbh->db), &(imp_dbh->tr), 0,
                                   sbuf, imp_dbh->sqldialect, NULL);

        if (ib_error_check(dbh, status))
            retval = -2;
        else
            retval = -1 ;
    }
    /* for AutoCommit: prepare/getinfo/exec statment (count DDL statements)
     * an easier and also working way would be to do that from perl with
     *   $sth = $dbh->prepare(...); $sth->execute();
     * but this way is much faster (no bind params, etc.)
     */
    else
    {
        isc_stmt_handle stmt = 0L;        /* temp statment handle */
        static char     stmt_info[] = { isc_info_sql_stmt_type };
        char            info_buffer[20];  /* statment info buffer */

        retval = -2;

        do
        {
            /* init statement handle */
            if (isc_dsql_alloc_statement2(status, &(imp_dbh->db), &stmt))
                break;


            /* prepare statement */
            isc_dsql_prepare(status, &(imp_dbh->tr), &stmt, 0, sbuf,
                             imp_dbh->sqldialect, NULL);
            if (ib_error_check(dbh, status))
                break;


            /* get statement type */
            if (!isc_dsql_sql_info(status, &stmt, sizeof(stmt_info), stmt_info,
                              sizeof(info_buffer), info_buffer))
            {
                /* need to count DDL statments */
                short l = (short) isc_vax_integer((char *) info_buffer + 1, 2);
                if (isc_vax_integer((char *) info_buffer + 3, l) == isc_info_sql_stmt_ddl)
                    imp_dbh->sth_ddl++;
            }
            else
                break;


            /* exec the statement */
            isc_dsql_execute(status, &(imp_dbh->tr), &stmt, imp_dbh->sqldialect, NULL);
            if (!ib_error_check(dbh, status))
                retval = -1;

        } while (0);

        /* close statement */
        if (stmt)
           isc_dsql_free_statement(status, &stmt, DSQL_drop);

        if (retval != -2) retval = -1;
    }

    /* for AutoCommit: commit */
    if (DBIc_has(imp_dbh, DBIcf_AutoCommit))
    {
        if (!ib_commit_transaction(dbh, imp_dbh))
            retval = -2;
    }

    if (retval < -1)
        XST_mUNDEF(0);
    else
        XST_mIV(0, retval); /* typically 1, rowcount or -1  */
}
#line 1023 "InterBase.c"
    }
    XSRETURN(1);
}

XS(XS_DBD__InterBase__db__ping); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__InterBase__db__ping)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: DBD::InterBase::db::_ping(dbh)");
    {
	SV *	dbh = ST(0);
	int	RETVAL;
	dXSTARG;
#line 185 "InterBase.xs"
{
    int ret;
    ret = dbd_db_ping(dbh);
    if (ret == 0)
        XST_mUNDEF(0);
    else
        XST_mIV(0, ret);
}
#line 1047 "InterBase.c"
    }
    XSRETURN(1);
}

XS(XS_DBD__InterBase__db_ib_set_tx_param); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__InterBase__db_ib_set_tx_param)
{
    dXSARGS;
    dXSI32;
    if (items < 1)
       Perl_croak(aTHX_ "Usage: %s(dbh, ...)", GvNAME(CvGV(cv)));
    {
	SV *	dbh = ST(0);
#line 200 "InterBase.xs"
    STRLEN len;
    char   *tx_key, *tx_val, *tpb, *tmp_tpb;
    int    i, rc = 0;
    int    tpb_len;
    char   am_set = 0, il_set = 0, ls_set = 0;
    I32    j;
    AV     *av;
    HV     *hv;
    SV     *sv, *sv_value;
    HE     *he;

#line 1073 "InterBase.c"
#line 212 "InterBase.xs"
{
    D_imp_dbh(dbh);

    /* if no params or first parameter = 0 or undef -> reset TPB to NULL */
    if (items < 3)
    {
        if ((items == 1) || !(SvTRUE(ST(1))))
        {
            tpb     = NULL;
            tmp_tpb = NULL;
            tpb_len = 0;
            goto do_set_tpb;
        }
    }

    /* we need to know the max. size of TBP, (buffer overflow problem) */
    /* mem usage: -access_mode:     max. 1 byte                        */
    /*            -isolation_level: max. 2 bytes                       */
    /*            -lock_resolution: max. 1 byte                        */
    /*            -reserving:       max. 4 bytes + strlen(tablename)   */
    tpb_len = 5; /* 4 + 1 for tpb_version                              */

    /* we need to add the length of each table name + 4 bytes */
    for (i = 1; i < items-1; i += 2)
    {
        sv_value = ST(i + 1);
        if (strEQ(SvPV_nolen(ST(i)), "-reserving"))
            if (SvROK(sv_value) && SvTYPE(SvRV(sv_value)) == SVt_PVHV)
            {
                hv = (HV *)SvRV(sv_value);
                hv_iterinit(hv);
                while (he = hv_iternext(hv))
                {
                    /* retrieve the size of table name(s) */
                    HePV(he, len);
                    tpb_len += len + 4;
                }
            }
    }

    /* alloc it */
    tmp_tpb = (char *)safemalloc(tpb_len * sizeof(char));

    if (tmp_tpb == NULL)
        croak("set_tx_param: Can't alloc memory");

    /* do set TPB values */
    tpb = tmp_tpb;
    *tpb++ = isc_tpb_version3;

    for (i = 1; i < items; i += 2)
    {
        tx_key   = SvPV_nolen(ST(i));
        sv_value = ST(i + 1);

        /* value specified? */
        if (i >= items - 1)
        {
            safefree(tmp_tpb);
            croak("You must specify parameter => value pairs, but theres no value for %s", tx_key);
        }

        /**********************************************************************/
        if (strEQ(tx_key, "-access_mode"))
        {
            if (am_set)
            {
                warn("-access_mode already set; ignoring second try!");
                continue;
            }

            tx_val = SvPV_nolen(sv_value);
            if (strEQ(tx_val, "read_write"))
                *tpb++ = isc_tpb_write;
            else if (strEQ(tx_val, "read_only"))
                *tpb++ = isc_tpb_read;
            else
            {
                safefree(tmp_tpb);
                croak("Unknown -access_mode value %s", tx_val);
            }

            am_set = 1; /* flag */
        }
        /**********************************************************************/
        else if (strEQ(tx_key, "-isolation_level"))
        {
            if (il_set)
            {
                warn("-isolation_level already set; ignoring second try!");
                continue;
            }

            if (SvROK(sv_value) && SvTYPE(SvRV(sv_value)) == SVt_PVAV)
            {
                av = (AV *)SvRV(sv_value);

                /* sanity check */
                for (j = 0; (j <= av_len(av)) && !rc; j++)
                {
                    sv = *av_fetch(av, j, FALSE);
                    if (strEQ(SvPV_nolen(sv), "read_committed"))
                    {
                        rc = 1;
                        *tpb++ = isc_tpb_read_committed;
                    }
                }

                if (!rc)
                {
                    safefree(tmp_tpb);
                    croak("Invalid -isolation_level value");
                }

                for (j = 0; j <= av_len(av); j++)
                {
                    tx_val = SvPV_nolen(*(av_fetch(av, j, FALSE)));
                    if (strEQ(tx_val, "record_version"))
                    {
                        *tpb++ = isc_tpb_rec_version;
                        break;
                    }
                    else if (strEQ(tx_val, "no_record_version"))
                    {
                        *tpb++ = isc_tpb_no_rec_version;
                        break;
                    }
                    else if (!strEQ(tx_val, "read_committed"))
                    {
                        safefree(tmp_tpb);
                        croak("Unknown -isolation_level value %s", tx_val);
                    }
                }
            }
            else
            {
                tx_val = SvPV_nolen(sv_value);
                if (strEQ(tx_val, "read_committed"))
                    *tpb++ = isc_tpb_read_committed;
                else if (strEQ(tx_val, "snapshot"))
                    *tpb++ = isc_tpb_concurrency;
                else if (strEQ(tx_val, "snapshot_table_stability"))
                    *tpb++ = isc_tpb_consistency;
                else
                {
                    safefree(tmp_tpb);
                    croak("Unknown -isolation_level value %s", tx_val);
                }
            }

            il_set = 1; /* flag */
        }
        /**********************************************************************/
        else if (strEQ(tx_key, "-lock_resolution"))
        {
            if (ls_set)
            {
                warn("-lock_resolution already set; ignoring second try!");
                continue;
            }

            tx_val = SvPV_nolen(sv_value);
            if (strEQ(tx_val, "wait"))
                *tpb++ = isc_tpb_wait;
            else if (strEQ(tx_val, "no_wait"))
                *tpb++ = isc_tpb_nowait;
            else
            {
                safefree(tmp_tpb);
                croak("Unknown transaction parameter %s", tx_val);
            }

            ls_set = 1; /* flag */
        }
        /**********************************************************************/
        else if (strEQ(tx_key, "-reserving"))
        {
            if (SvROK(sv_value) && SvTYPE(SvRV(sv_value)) == SVt_PVHV)
            {
                char *table_name;
                HV *table_opts;
                hv = (HV *)SvRV(sv_value);
                hv_iterinit(hv);
                while (he = hv_iternext(hv))
                {
                    /* check val type */
                    if (SvROK(HeVAL(he)) && SvTYPE(SvRV(HeVAL(he))) == SVt_PVHV)
                    {
                        table_opts = (HV*)SvRV(HeVAL(he));

                        if (hv_exists(table_opts, "access", 6))
                        {
                            /* access is optional */
                            sv = *hv_fetch(table_opts, "access", 6, FALSE);
                            if (strnEQ(SvPV_nolen(sv), "shared", 6))
                                *tpb++ = isc_tpb_shared;
                            else if (strnEQ(SvPV_nolen(sv), "protected", 9))
                                *tpb++ = isc_tpb_protected;
                            else
                            {
                                safefree(tmp_tpb);
                                croak("Invalid -reserving access value");
                            }
                        }

                        if (hv_exists(table_opts, "lock", 4))
                        {
                            /* lock is required */
                            sv = *hv_fetch(table_opts, "lock", 4, FALSE);
                            if (strnEQ(SvPV_nolen(sv), "read", 4))
                               *tpb++ = isc_tpb_lock_read;
                            else if (strnEQ(SvPV_nolen(sv), "write", 5))
                               *tpb++ = isc_tpb_lock_write;
                            else
                            {
                              safefree(tmp_tpb);
                              croak("Invalid -reserving lock value");
                            }
                        }
                        else /* lock */
                        {
                            safefree(tmp_tpb);
                            croak("Lock value is required in -reserving");
                        }

                        /* add the table name to TPB */
                        table_name = HePV(he, len);
                        *tpb++ = len + 1;
                        {
                            unsigned int k;
                            for (k = 0; k < len; k++)
                                *tpb++ = toupper(*table_name++);
                        }
                        *tpb++ = 0;
                    } /* end hashref check*/
                    else
                    {
                        safefree(tmp_tpb);
                        croak("Reservation for a given table must be hashref.");
                    }
                } /* end of while() */
            }
            else
            {
                safefree(tmp_tpb);
                croak("Invalid -reserving value. Must be hashref.");
            }
        } /* end table reservation */
        else
        {
            safefree(tmp_tpb);
            croak("Unknown transaction parameter %s", tx_key);
        }
    }

    /* an ugly label... */
    do_set_tpb:

    safefree(imp_dbh->tpb_buffer);
    imp_dbh->tpb_buffer = tmp_tpb;
    imp_dbh->tpb_length = tpb - imp_dbh->tpb_buffer;

    /* for AutoCommit: commit current transaction */
    if (DBIc_has(imp_dbh, DBIcf_AutoCommit))
    {
        imp_dbh->sth_ddl++;
        ib_commit_transaction(dbh, imp_dbh);
    }
}
#line 1344 "InterBase.c"
    }
    XSRETURN(1);
}

#define DB_INFOBUF(name, len) \
if (strEQ(item, #name)) { \
    *p++ = (char) isc_info_##name; \
    res_len += len + 3; \
    item_buf_len++; \
    continue; \
}
#define DB_RESBUF_CASEHDR(name) \
case isc_info_##name:\
    keyname = #name;
XS(XS_DBD__InterBase__db_ib_database_info); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__InterBase__db_ib_database_info)
{
    dXSARGS;
    if (items < 1)
	Perl_croak(aTHX_ "Usage: DBD::InterBase::db::ib_database_info(dbh, ...)");
    {
	SV *	dbh = ST(0);
#line 501 "InterBase.xs"
    unsigned int i, count;
    char  item_buf[30], *p, *old_p;
    char *res_buf;
    short item_buf_len, res_len;
    AV    *av;
    ISC_STATUS status[ISC_STATUS_LENGTH];
#line 1374 "InterBase.c"
	HV *	RETVAL;
#line 508 "InterBase.xs"
{
    D_imp_dbh(dbh);

    /* process input params, count max. result buffer length */
    p = item_buf;
    res_len = 0;
    item_buf_len = 0;

    /* array or array ref? */
    if (items == 2 && SvROK(ST(1)) && SvTYPE(SvRV(ST(1))) == SVt_PVAV)
    {
        av    = (AV *)SvRV(ST(1));
        count = av_len(av) + 1;
    }
    else
    {
        av    = NULL;
        count = items;
    }

    /* loop thru all elements */
    for (i = 0; i < count; i++)
    {
        char *item;

        /* fetch from array or array ref? */
        if (av)
            item = SvPV_nolen(*av_fetch(av, i, FALSE));
        else
            item = SvPV_nolen(ST(i + 1));

        /* database characteristics */
        DB_INFOBUF(allocation,        4);
        DB_INFOBUF(base_level,        2);
        DB_INFOBUF(db_id,           513);
        DB_INFOBUF(implementation,    3);
        DB_INFOBUF(no_reserve,        1);
#ifdef IB_API_V6
        DB_INFOBUF(db_read_only,      1);
#endif
        DB_INFOBUF(ods_minor_version, 1);
        DB_INFOBUF(ods_version,       1);
        DB_INFOBUF(page_size,         4);
        DB_INFOBUF(version,         257);
#ifdef IB_API_V6
        DB_INFOBUF(db_sql_dialect,    1);
#endif

        /* environmental characteristics */
        DB_INFOBUF(current_memory,    4);
        DB_INFOBUF(forced_writes,     1);
        DB_INFOBUF(max_memory,        4);
        DB_INFOBUF(num_buffers,       4);
        DB_INFOBUF(sweep_interval,    4);
        DB_INFOBUF(user_names,     1024); /* can be more, can be less */

        /* performance statistics */
        DB_INFOBUF(fetches, 4);
        DB_INFOBUF(marks,   4);
        DB_INFOBUF(reads,   4);
        DB_INFOBUF(writes,  4);

        /* database operation counts */
        /* XXX - not implemented (complicated: returns a descriptor for _each_
           table...how to fetch / store this??) but do we really need these? */
    }

    /* the end marker */
    *p++ = isc_info_end;
    item_buf_len++;

    /* allocate the result buffer */
    res_len += 256; /* add some safety...just in case */
    res_buf = (char *) safemalloc(res_len);

    /* call the function */
    isc_database_info(status, &(imp_dbh->db), item_buf_len, item_buf,
                      res_len, res_buf);

    if (ib_error_check(dbh, status))
    {
        safefree(res_buf);
        croak("isc_database_info failed!");
    }

    /* create a hash if function passed */
    RETVAL = newHV();
    if (!RETVAL)
    {
        safefree(res_buf);
        croak("unable to allocate hash return value");
    }

    /* fill the hash with key/value pairs */
    for (p = res_buf; *p != isc_info_end; )
    {
        char *keyname;
        char item   = *p++;
        int  length = isc_vax_integer (p, 2);
        p += 2;
        old_p = p;

        switch (item)
        {
            /******************************************************************/
            /* database characteristics */
            DB_RESBUF_CASEHDR(allocation)
                hv_store(RETVAL, keyname, strlen(keyname),
                         newSViv(isc_vax_integer(p, (short) length)), 0);
                break;

            DB_RESBUF_CASEHDR(base_level)
                hv_store(RETVAL, keyname, strlen(keyname),
                         newSViv(isc_vax_integer(++p, 1)), 0);
                break;

            DB_RESBUF_CASEHDR(db_id)
            {
                HV *reshv = newHV();
                long slen;

                hv_store(reshv, "connection", 10,
                         (isc_vax_integer(p++, 1) == 2)?
                             newSVpv("local", 0):
                             newSVpv("remote", 0),
                         0);

                slen = isc_vax_integer(p++, 1);
                hv_store(reshv, "database", 8, newSVpvn(p, slen), 0);
                p += slen;

                slen = isc_vax_integer(p++, 1);
                hv_store(reshv, "site", 8, newSVpvn(p, slen), 0);

                hv_store(RETVAL, keyname, strlen(keyname),
                         newRV_noinc((SV *) reshv), 0);
                break;
            }

            DB_RESBUF_CASEHDR(implementation)
            {
                HV *reshv = newHV();

                hv_store(reshv, "implementation", 14,
                         newSViv(isc_vax_integer(++p, 1)), 0);

                hv_store(reshv, "class", 5,
                         newSViv(isc_vax_integer(++p, 1)), 0);

                hv_store(RETVAL, keyname, strlen(keyname),
                         newRV_noinc((SV *) reshv), 0);

                break;
            }

            DB_RESBUF_CASEHDR(no_reserve)
                hv_store(RETVAL, keyname, strlen(keyname),
                         newSViv(isc_vax_integer(p, (short) length)), 0);
                break;
#ifdef IB_API_V6
            DB_RESBUF_CASEHDR(db_read_only)
                hv_store(RETVAL, keyname, strlen(keyname),
                         newSViv(isc_vax_integer(p, (short) length)), 0);
                break;
#endif
            DB_RESBUF_CASEHDR(ods_minor_version)
                hv_store(RETVAL, keyname, strlen(keyname),
                         newSViv(isc_vax_integer(p, (short) length)), 0);
                break;

            DB_RESBUF_CASEHDR(ods_version)
                hv_store(RETVAL, keyname, strlen(keyname),
                         newSViv(isc_vax_integer(p, (short) length)), 0);
                break;

            DB_RESBUF_CASEHDR(page_size)
                hv_store(RETVAL, keyname, strlen(keyname),
                         newSViv(isc_vax_integer(p, (short) length)), 0);
                break;

            DB_RESBUF_CASEHDR(version)
            {
                long slen;
                slen = isc_vax_integer(++p, 1);
                hv_store(RETVAL, keyname, strlen(keyname),
                         newSVpvn(++p, slen), 0);
                break;
            }
#ifdef isc_dpb_sql_dialect
            DB_RESBUF_CASEHDR(db_sql_dialect)
                hv_store(RETVAL, keyname, strlen(keyname),
                         newSViv(isc_vax_integer(p, (short) length)), 0);
                break;
#endif

            /******************************************************************/
            /* environmental characteristics */
            DB_RESBUF_CASEHDR(current_memory)
                hv_store(RETVAL, keyname, strlen(keyname),
                         newSViv(isc_vax_integer(p, (short) length)), 0);
                break;

            DB_RESBUF_CASEHDR(forced_writes)
                hv_store(RETVAL, keyname, strlen(keyname),
                         newSViv(isc_vax_integer(p, (short) length)), 0);
                break;

            DB_RESBUF_CASEHDR(max_memory)
                hv_store(RETVAL, keyname, strlen(keyname),
                         newSViv(isc_vax_integer(p, (short) length)), 0);
                break;

            DB_RESBUF_CASEHDR(num_buffers)
                hv_store(RETVAL, keyname, strlen(keyname),
                         newSViv(isc_vax_integer(p, (short) length)), 0);
                break;

            DB_RESBUF_CASEHDR(sweep_interval)
                hv_store(RETVAL, keyname, strlen(keyname),
                         newSViv(isc_vax_integer(p, (short) length)), 0);
                break;

            DB_RESBUF_CASEHDR(user_names)
            {
                AV *avres;
                SV **svp;
                long slen;

                /* array already existing? no -> create */
                if (!hv_exists(RETVAL, "user_names", 10))
                {
                    avres = newAV();
                    hv_store(RETVAL, "user_names", 10,
                             newRV_noinc((SV *) avres), 0);
                }
                else
                {
                    svp = hv_fetch(RETVAL, "user_names", 10, 0);
                    if (!svp || !SvROK(*svp))
                    {
                        safefree(res_buf);
                        croak("Error fetching hash value");
                    }

                    avres = (AV *) SvRV(*svp);
                }

                /* add value to the array */
                slen = isc_vax_integer(p++, 1);
                av_push(avres, newSVpvn(p, slen));

                break;
            }

            /******************************************************************/
            /* performance statistics */
            DB_RESBUF_CASEHDR(fetches)
                hv_store(RETVAL, keyname, strlen(keyname),
                         newSViv(isc_vax_integer(p, (short) length)), 0);
                break;

            DB_RESBUF_CASEHDR(marks)
                hv_store(RETVAL, keyname, strlen(keyname),
                         newSViv(isc_vax_integer(p, (short) length)), 0);
                break;

            DB_RESBUF_CASEHDR(reads)
                hv_store(RETVAL, keyname, strlen(keyname),
                         newSViv(isc_vax_integer(p, (short) length)), 0);
                break;

            DB_RESBUF_CASEHDR(writes)
                hv_store(RETVAL, keyname, strlen(keyname),
                         newSViv(isc_vax_integer(p, (short) length)), 0);
                break;

            default:
                break;
        }

        p = old_p + length;
    }

    /* don't leak */
    safefree(res_buf);
}
#line 1663 "InterBase.c"
	ST(0) = newRV((SV*)RETVAL);
	sv_2mortal(ST(0));
#line 798 "InterBase.xs"
    SvREFCNT_dec(RETVAL);
#line 1668 "InterBase.c"
    }
    XSRETURN(1);
}

#undef DB_INFOBUF
#undef DB_RESBUF_CASEHDR
XS(XS_DBD__InterBase__db_ib_init_event); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__InterBase__db_ib_init_event)
{
    dXSARGS;
    if (items < 1)
	Perl_croak(aTHX_ "Usage: DBD::InterBase::db::ib_init_event(dbh, ...)");
    {
	SV *	dbh = ST(0);
#line 809 "InterBase.xs"
    char *CLASS = "DBD::InterBase::Event";
    int i;
    D_imp_dbh(dbh);
#line 1687 "InterBase.c"
	IB_EVENT *	RETVAL;
#line 813 "InterBase.xs"
{
    unsigned short cnt = items - 1;

    DBI_TRACE(2, (DBILOGFP, "Entering init_event(), %d items..\n", cnt));

    if (cnt > 0)
    {
        /* check for max number of events in a single call to event block allocation */
        if (cnt > MAX_EVENTS)
            croak("Max number of events exceeded.");

        RETVAL = (IB_EVENT *) safemalloc(sizeof(IB_EVENT));
        if (RETVAL == NULL)
            croak("Unable to allocate memory");

        /* init members */
        RETVAL->dbh           = imp_dbh;
        RETVAL->event_buffer  = NULL;
        RETVAL->result_buffer = NULL;
        RETVAL->id            = 0;
        RETVAL->reinit        = 0;
        RETVAL->num           = cnt;
        RETVAL->perl_cb       = NULL;
        RETVAL->cb_called     = 0;

        RETVAL->names = (char **) safemalloc(sizeof(char*) * MAX_EVENTS);
        if (RETVAL->names == NULL)
            croak("Unable to allocate memory");

        for (i = 0; i < MAX_EVENTS; i++)
        {
            if (i < cnt) {
                /* dangerous! 
                *(RETVAL->names + i) = SvPV_nolen(ST(i + 1));
                */
                RETVAL->names[i] = (char*) safemalloc(sizeof(char) * (SvCUR(ST(i + 1)) + 1));
                if (RETVAL->names[i] == NULL) 
                    croak("Unable to allocate memory");
                strcpy(RETVAL->names[i], SvPV_nolen(ST(i + 1)));
            }
            else
                *(RETVAL->names + i) = NULL;
        }

        RETVAL->epb_length = (short) isc_event_block(
            &(RETVAL->event_buffer),
            &(RETVAL->result_buffer),
            cnt,
            *(RETVAL->names +  0),
            *(RETVAL->names +  1),
            *(RETVAL->names +  2),
            *(RETVAL->names +  3),
            *(RETVAL->names +  4),
            *(RETVAL->names +  5),
            *(RETVAL->names +  6),
            *(RETVAL->names +  7),
            *(RETVAL->names +  8),
            *(RETVAL->names +  9),
            *(RETVAL->names + 10),
            *(RETVAL->names + 11),
            *(RETVAL->names + 12),
            *(RETVAL->names + 13),
            *(RETVAL->names + 14));
    }
    else
        croak("Names of the events in interest are not specified");

    DBI_TRACE(2, (DBILOGFP, "Leaving init_event()\n"));
}
#line 1759 "InterBase.c"
	ST(0) = sv_newmortal();
    sv_setref_pv( ST(0), CLASS, (void*)RETVAL );

    }
    XSRETURN(1);
}

XS(XS_DBD__InterBase__db_ib_register_callback); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__InterBase__db_ib_register_callback)
{
    dXSARGS;
    if (items != 3)
	Perl_croak(aTHX_ "Usage: DBD::InterBase::db::ib_register_callback(dbh, ev, perl_cb)");
    {
	SV *	dbh = ST(0);
	IB_EVENT *	ev;
	SV *	perl_cb = ST(2);
#line 892 "InterBase.xs"
    ISC_STATUS status[ISC_STATUS_LENGTH];
    D_imp_dbh(dbh);
#line 1780 "InterBase.c"
	int	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) )
        ev = (IB_EVENT *)SvIV((SV*)SvRV( ST(1) ));
    else{
        warn( "DBD::InterBase::db::ib_register_callback() -- ev is not a blessed SV reference" );
        XSRETURN_UNDEF;
    };
#line 895 "InterBase.xs"
{
    DBI_TRACE(2, (DBILOGFP, "Entering register_callback()..\n"));

    /* save the perl callback function */
    ev->perl_cb = perl_cb;

    /* set up the events */
    isc_que_events(
        status,
        &(imp_dbh->db),
        &(ev->id),
        ev->epb_length,
        ev->event_buffer,
        (isc_callback)_async_callback,
        ev);

    if (ib_error_check(dbh, status))
        RETVAL = 0;
    else
        RETVAL = 1;

    DBI_TRACE(2, (DBILOGFP, "Leaving register_callback(): %d\n", RETVAL));
}
#line 1814 "InterBase.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_DBD__InterBase__db_ib_reinit_event); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__InterBase__db_ib_reinit_event)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: DBD::InterBase::db::ib_reinit_event(dbh, ev)");
    {
	SV *	dbh = ST(0);
	IB_EVENT *	ev;
#line 927 "InterBase.xs"
    int i;
    SV  **svp;
    ISC_STATUS status[ISC_STATUS_LENGTH];
#line 1833 "InterBase.c"
	HV *	RETVAL;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) )
        ev = (IB_EVENT *)SvIV((SV*)SvRV( ST(1) ));
    else{
        warn( "DBD::InterBase::db::ib_reinit_event() -- ev is not a blessed SV reference" );
        XSRETURN_UNDEF;
    };
#line 931 "InterBase.xs"
{
    DBI_TRACE(2, (DBILOGFP, "reinit_event() - reinit value: %d.\n",
                  (int)ev->reinit));

    RETVAL = newHV();
    /* if (ev->reinit) { */
    if (1)
    {
        isc_event_counts(status, ev->epb_length, ev->event_buffer,
                         ev->result_buffer);
        for (i = 0; i < ev->num; i++)
        {
            if (status[i])
            {
                DBI_TRACE(2, (DBILOGFP, "Event %s caught %ld times.\n",
                              *(ev->names + i), status[i]));

                svp = hv_store(RETVAL, *(ev->names + i), strlen(*(ev->names + i)),
                               newSViv(status[i]), 0);
                if (svp == NULL)
                    croak("Bad: key '%s' not stored", *(ev->names + i));
            }
        }
    }
    else
        ev->reinit = 1;

    ev->cb_called = 0;
}
#line 1872 "InterBase.c"
	ST(0) = newRV((SV*)RETVAL);
	sv_2mortal(ST(0));
#line 963 "InterBase.xs"
    SvREFCNT_dec(RETVAL);
#line 1877 "InterBase.c"
    }
    XSRETURN(1);
}

XS(XS_DBD__InterBase__db_ib_cancel_callback); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__InterBase__db_ib_cancel_callback)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: DBD::InterBase::db::ib_cancel_callback(dbh, ev)");
    {
	SV *	dbh = ST(0);
	IB_EVENT *	ev;
#line 971 "InterBase.xs"
    ISC_STATUS status[ISC_STATUS_LENGTH];
    D_imp_dbh(dbh);
#line 1894 "InterBase.c"
	int	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) )
        ev = (IB_EVENT *)SvIV((SV*)SvRV( ST(1) ));
    else{
        warn( "DBD::InterBase::db::ib_cancel_callback() -- ev is not a blessed SV reference" );
        XSRETURN_UNDEF;
    };
#line 974 "InterBase.xs"
{
    DBI_TRACE(2, (DBILOGFP, "Entering cancel_callback()..\n"));

    if (ev->perl_cb)
        isc_cancel_events(status, &(imp_dbh->db), &(ev->id));

    if (ib_error_check(dbh, status))
    {
        do_error(dbh, 2, "cancel_callback() error");
        RETVAL = 0;
    }
    else
        RETVAL = 1;
}
#line 1919 "InterBase.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_DBD__InterBase__db_ib_wait_event); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__InterBase__db_ib_wait_event)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: DBD::InterBase::db::ib_wait_event(dbh, ev)");
    {
	SV *	dbh = ST(0);
	IB_EVENT *	ev;
#line 997 "InterBase.xs"
    ISC_STATUS status[ISC_STATUS_LENGTH];
    D_imp_dbh(dbh);
#line 1937 "InterBase.c"
	int	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) )
        ev = (IB_EVENT *)SvIV((SV*)SvRV( ST(1) ));
    else{
        warn( "DBD::InterBase::db::ib_wait_event() -- ev is not a blessed SV reference" );
        XSRETURN_UNDEF;
    };
#line 1000 "InterBase.xs"
{
    isc_wait_for_event(status, &(imp_dbh->db), ev->epb_length, ev->event_buffer,
                       ev->result_buffer);

    if (ib_error_check(dbh, status))
    {
        do_error(dbh, 2, "wait_event() error");
        RETVAL = 0;
    }
    else
        RETVAL = 1;
}
#line 1960 "InterBase.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_DBD__InterBase__Event_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__InterBase__Event_DESTROY)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: DBD::InterBase::Event::DESTROY(evh)");
    {
	IB_EVENT *	evh;
#line 1023 "InterBase.xs"
    int i;
    ISC_STATUS status[ISC_STATUS_LENGTH];
#line 1977 "InterBase.c"

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
        evh = (IB_EVENT *)SvIV((SV*)SvRV( ST(0) ));
    else{
        warn( "DBD::InterBase::Event::DESTROY() -- evh is not a blessed SV reference" );
        XSRETURN_UNDEF;
    };
#line 1026 "InterBase.xs"
{
    DBI_TRACE(2, (DBILOGFP, "Entering DBD::InterBase::Event destructor..\n"));

    for (i = 0; i < evh->num; i++)
        if (*(evh->names + i))
            safefree(*(evh->names + i));
    if (evh->names)
        safefree(evh->names);
    if (evh->perl_cb)
        isc_cancel_events(status, &(evh->dbh->db), &(evh->id));
    if (evh->event_buffer)
        isc_free(evh->event_buffer);
    if (evh->result_buffer)
        isc_free(evh->result_buffer);
}
#line 2001 "InterBase.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_DBD__InterBase__Event_callback_called); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__InterBase__Event_callback_called)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: DBD::InterBase::Event::callback_called(evh)");
    {
	IB_EVENT *	evh;
	int	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
        evh = (IB_EVENT *)SvIV((SV*)SvRV( ST(0) ));
    else{
        warn( "DBD::InterBase::Event::callback_called() -- evh is not a blessed SV reference" );
        XSRETURN_UNDEF;
    };
#line 1046 "InterBase.xs"
    RETVAL = evh->cb_called;
#line 2025 "InterBase.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_DBD__InterBase__st_ib_plan); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__InterBase__st_ib_plan)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: DBD::InterBase::st::ib_plan(sth)");
    {
	SV *	sth = ST(0);
	char *	RETVAL;
	dXSTARG;
#line 1056 "InterBase.xs"
{
    D_imp_sth(sth);
    ISC_STATUS  status[ISC_STATUS_LENGTH];
    char plan_info[1];
    char plan_buffer[PLAN_BUFFER_LEN];

    RETVAL = NULL;
    memset(plan_buffer, 0, PLAN_BUFFER_LEN);
    plan_info[0] = isc_info_sql_get_plan;

    if (isc_dsql_sql_info(status, &(imp_sth->stmt), sizeof(plan_info), plan_info,
                  sizeof(plan_buffer), plan_buffer)) 
    {
        if (ib_error_check(sth, status))
        {
            ib_cleanup_st_prepare(imp_sth);
            XSRETURN_UNDEF;
        }
    }
    if (plan_buffer[0] == isc_info_sql_get_plan) {
        short l = (short) isc_vax_integer((char *)plan_buffer + 1, 2);
        if ((RETVAL = (char*)safemalloc(sizeof(char) * (l + 2))) == NULL) {
            do_error(sth, 2, "Failed to allocate plan buffer");
            XSRETURN_UNDEF;
        }
        sprintf(RETVAL, "%.*s%s", l, plan_buffer + 3, "\n");
        //PerlIO_printf(PerlIO_stderr(), "Len: %d, orig len: %d\n", strlen(imp_sth->plan), l);
    }
}
#line 2071 "InterBase.c"
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}

#ifdef __cplusplus
extern "C"
#endif
XS(boot_DBD__InterBase); /* prototype to pass -Wmissing-prototypes */
XS(boot_DBD__InterBase)
{
    dXSARGS;
    char* file = __FILE__;

    XS_VERSION_BOOTCHECK ;

    {
        CV * cv ;

#if XSubPPtmpAAAA
        cv = newXS("DBD::InterBase::dr::discon_all_", XS_DBD__InterBase__dr_discon_all_, file);
        XSANY.any_i32 = 0 ;
        cv = newXS("DBD::InterBase::dr::disconnect_all", XS_DBD__InterBase__dr_discon_all_, file);
        XSANY.any_i32 = 1 ;
#endif
#if XSubPPtmpAAAB
        newXS("DBD::InterBase::dr::data_sources", XS_DBD__InterBase__dr_data_sources, file);
#endif
        newXS("DBD::InterBase::db::_login", XS_DBD__InterBase__db__login, file);
        newXS("DBD::InterBase::db::selectall_arrayref", XS_DBD__InterBase__db_selectall_arrayref, file);
        cv = newXS("DBD::InterBase::db::selectrow_arrayref", XS_DBD__InterBase__db_selectrow_arrayref, file);
        XSANY.any_i32 = 0 ;
        cv = newXS("DBD::InterBase::db::selectrow_array", XS_DBD__InterBase__db_selectrow_arrayref, file);
        XSANY.any_i32 = 1 ;
#if XSubPPtmpAAAC
        newXS("DBD::InterBase::db::do", XS_DBD__InterBase__db_do, file);
#endif
        newXS("DBD::InterBase::db::commit", XS_DBD__InterBase__db_commit, file);
        newXS("DBD::InterBase::db::rollback", XS_DBD__InterBase__db_rollback, file);
        newXS("DBD::InterBase::db::disconnect", XS_DBD__InterBase__db_disconnect, file);
        newXS("DBD::InterBase::db::STORE", XS_DBD__InterBase__db_STORE, file);
        newXS("DBD::InterBase::db::FETCH", XS_DBD__InterBase__db_FETCH, file);
        newXS("DBD::InterBase::db::DESTROY", XS_DBD__InterBase__db_DESTROY, file);
        newXS("DBD::InterBase::st::_prepare", XS_DBD__InterBase__st__prepare, file);
#if XSubPPtmpAAAD
        newXS("DBD::InterBase::st::rows", XS_DBD__InterBase__st_rows, file);
#endif
        newXS("DBD::InterBase::st::bind_param", XS_DBD__InterBase__st_bind_param, file);
        newXS("DBD::InterBase::st::bind_param_inout", XS_DBD__InterBase__st_bind_param_inout, file);
        newXS("DBD::InterBase::st::execute", XS_DBD__InterBase__st_execute, file);
        cv = newXS("DBD::InterBase::st::fetchrow_arrayref", XS_DBD__InterBase__st_fetchrow_arrayref, file);
        XSANY.any_i32 = 0 ;
        cv = newXS("DBD::InterBase::st::fetch", XS_DBD__InterBase__st_fetchrow_arrayref, file);
        XSANY.any_i32 = 1 ;
        cv = newXS("DBD::InterBase::st::fetchrow_array", XS_DBD__InterBase__st_fetchrow_array, file);
        XSANY.any_i32 = 0 ;
        cv = newXS("DBD::InterBase::st::fetchrow", XS_DBD__InterBase__st_fetchrow_array, file);
        XSANY.any_i32 = 1 ;
        newXS("DBD::InterBase::st::fetchall_arrayref", XS_DBD__InterBase__st_fetchall_arrayref, file);
        newXS("DBD::InterBase::st::finish", XS_DBD__InterBase__st_finish, file);
        newXS("DBD::InterBase::st::blob_read", XS_DBD__InterBase__st_blob_read, file);
        newXS("DBD::InterBase::st::STORE", XS_DBD__InterBase__st_STORE, file);
        cv = newXS("DBD::InterBase::st::FETCH_attrib", XS_DBD__InterBase__st_FETCH_attrib, file);
        XSANY.any_i32 = 0 ;
        cv = newXS("DBD::InterBase::st::FETCH", XS_DBD__InterBase__st_FETCH_attrib, file);
        XSANY.any_i32 = 1 ;
        newXS("DBD::InterBase::st::DESTROY", XS_DBD__InterBase__st_DESTROY, file);
        newXSproto("DBD::InterBase::db::_do", XS_DBD__InterBase__db__do, file, "$$;$@");
        newXS("DBD::InterBase::db::_ping", XS_DBD__InterBase__db__ping, file);
        cv = newXS("DBD::InterBase::db::ib_set_tx_param", XS_DBD__InterBase__db_ib_set_tx_param, file);
        XSANY.any_i32 = 0 ;
        cv = newXS("DBD::InterBase::db::set_tx_param", XS_DBD__InterBase__db_ib_set_tx_param, file);
        XSANY.any_i32 = 1 ;
        newXS("DBD::InterBase::db::ib_database_info", XS_DBD__InterBase__db_ib_database_info, file);
        newXS("DBD::InterBase::db::ib_init_event", XS_DBD__InterBase__db_ib_init_event, file);
        newXS("DBD::InterBase::db::ib_register_callback", XS_DBD__InterBase__db_ib_register_callback, file);
        newXS("DBD::InterBase::db::ib_reinit_event", XS_DBD__InterBase__db_ib_reinit_event, file);
        newXS("DBD::InterBase::db::ib_cancel_callback", XS_DBD__InterBase__db_ib_cancel_callback, file);
        newXS("DBD::InterBase::db::ib_wait_event", XS_DBD__InterBase__db_ib_wait_event, file);
        newXS("DBD::InterBase::Event::DESTROY", XS_DBD__InterBase__Event_DESTROY, file);
        newXS("DBD::InterBase::Event::callback_called", XS_DBD__InterBase__Event_callback_called, file);
        newXS("DBD::InterBase::st::ib_plan", XS_DBD__InterBase__st_ib_plan, file);
    }

    /* Initialisation Section */

#line 18 "InterBase.xsi"
    items = 0;  /* avoid 'unused variable' warning */
    DBISTATE_INIT;
    /* XXX this interface will change: */
    DBI_IMP_SIZE("DBD::InterBase::dr::imp_data_size", sizeof(imp_drh_t));
    DBI_IMP_SIZE("DBD::InterBase::db::imp_data_size", sizeof(imp_dbh_t));
    DBI_IMP_SIZE("DBD::InterBase::st::imp_data_size", sizeof(imp_sth_t));
    dbd_init(DBIS);

#if XSubPPtmpAAAA
#endif
#if XSubPPtmpAAAB
#endif
#if XSubPPtmpAAAC
#endif
#if XSubPPtmpAAAD
#endif
#line 2175 "InterBase.c"

    /* End of Initialisation Section */

    XSRETURN_YES;
}

