/*
 * This file was generated automatically by xsubpp version 1.9508 from the
 * contents of FCGI.xs. Do not edit this file, edit FCGI.xs instead.
 *
 *	ANY CHANGES MADE HERE WILL BE LOST!
 *
 */

#line 1 "FCGI.xs"
/* $Id: FCGI.XL,v 1.9 2002/11/11 13:51:20 skimo Exp $ */

#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"

#include "fcgi_config.h"
#include "fcgiapp.h"
#include "fastcgi.h"

#ifndef FALSE
#define FALSE (0)
#endif

#ifndef TRUE
#define TRUE  (1)
#endif

#ifndef dTHX
#define dTHX
#endif

#ifndef INT2PTR
#define INT2PTR(a,b) ((a) (b))
#endif

#ifdef USE_SFIO
typedef struct
{
    Sfdisc_t	disc;
    FCGX_Stream	*stream;
} FCGI_Disc;

static ssize_t
sffcgiread(f, buf, n, disc)
Sfio_t*		f;      /* stream involved */
Void_t*		buf;    /* buffer to read into */
size_t		n;      /* number of bytes to read */
Sfdisc_t*	disc;   /* discipline */
{
    return FCGX_GetStr(buf, n, ((FCGI_Disc *)disc)->stream);
}

static ssize_t
sffcgiwrite(f, buf, n, disc)
Sfio_t*		f;      /* stream involved */
const Void_t*	buf;    /* buffer to read into */
size_t		n;      /* number of bytes to read */
Sfdisc_t*	disc;   /* discipline */
{
    n = FCGX_PutStr(buf, n, ((FCGI_Disc *)disc)->stream);
    FCGX_FFlush(((FCGI_Disc *)disc)->stream);
    return n;
}

Sfdisc_t *
sfdcnewfcgi(stream)
	FCGX_Stream *stream;
{
    FCGI_Disc*	disc;

    New(1000,disc,1,FCGI_Disc);
    if (!disc) return (Sfdisc_t *)disc;

    disc->disc.exceptf = (Sfexcept_f)NULL;
    disc->disc.seekf = (Sfseek_f)NULL;
    disc->disc.readf = sffcgiread;
    disc->disc.writef = sffcgiwrite;
    disc->stream = stream;
    return (Sfdisc_t *)disc;
}

Sfdisc_t *
sfdcdelfcgi(disc)
    Sfdisc_t*	disc;
{
    Safefree(disc);
    return 0;
}
#endif

#if defined(USE_LOCKING) && defined(USE_THREADS)
static perl_mutex   accept_mutex;
#endif

typedef struct FCGP_Request {
    int		    accepted;
    int		    bound;
    SV*		    svin;
    SV*		    svout;
    SV*		    sverr;
    GV*		    gv[3];
    HV*		    hvEnv;
    FCGX_Request*   requestPtr;
#ifdef USE_SFIO
    int		    sfcreated[3];
    IO*		    io[3];
#endif
} FCGP_Request;

static void FCGI_Finish(FCGP_Request* request);

static void 
FCGI_Flush(FCGP_Request* request)
{
    dTHX;

    if(!request->bound) {
	return;
	}
#ifdef USE_SFIO
    sfsync(IoOFP(GvIOp(request->gv[1])));
    sfsync(IoOFP(GvIOp(request->gv[2])));
#else
    FCGX_FFlush(INT2PTR(FCGX_Stream *, SvIV((SV*) SvRV(request->svout))));
    FCGX_FFlush(INT2PTR(FCGX_Stream *, SvIV((SV*) SvRV(request->sverr))));
#endif
}

static void
FCGI_UndoBinding(FCGP_Request* request)
{
    dTHX;

#ifdef USE_SFIO
    sfdcdelfcgi(sfdisc(IoIFP(request->io[0]), SF_POPDISC));
    sfdcdelfcgi(sfdisc(IoOFP(request->io[1]), SF_POPDISC));
    sfdcdelfcgi(sfdisc(IoOFP(request->io[2]), SF_POPDISC));
#else
#  ifdef USE_PERLIO
    sv_unmagic((SV *)GvIOp(request->gv[0]), 'q');
    sv_unmagic((SV *)GvIOp(request->gv[1]), 'q');
    sv_unmagic((SV *)GvIOp(request->gv[2]), 'q');
#  else
    sv_unmagic((SV *)request->gv[0], 'q');
    sv_unmagic((SV *)request->gv[1], 'q');
    sv_unmagic((SV *)request->gv[2], 'q');
#  endif
#endif
    request->bound = FALSE;
}

static void
FCGI_Bind(FCGP_Request* request)
{
    dTHX;

#ifdef USE_SFIO
    sfdisc(IoIFP(request->io[0]), sfdcnewfcgi(request->requestPtr->in));
    sfdisc(IoOFP(request->io[1]), sfdcnewfcgi(request->requestPtr->out));
    sfdisc(IoOFP(request->io[2]), sfdcnewfcgi(request->requestPtr->err));
#else
#  ifdef USE_PERLIO
    /* For tied filehandles, we apply tiedscalar magic to the IO
       slot of the GP rather than the GV itself. */

    if (!GvIOp(request->gv[1]))
	GvIOp(request->gv[1]) = newIO();
    if (!GvIOp(request->gv[2]))
	GvIOp(request->gv[2]) = newIO();
    if (!GvIOp(request->gv[0]))
	GvIOp(request->gv[0]) = newIO();

    sv_magic((SV *)GvIOp(request->gv[1]), request->svout, 'q', Nullch, 0);
    sv_magic((SV *)GvIOp(request->gv[2]), request->sverr, 'q', Nullch, 0);
    sv_magic((SV *)GvIOp(request->gv[0]), request->svin, 'q', Nullch, 0);
#  else
    sv_magic((SV *)request->gv[1], request->svout, 'q', Nullch, 0);
    sv_magic((SV *)request->gv[2], request->sverr, 'q', Nullch, 0);
    sv_magic((SV *)request->gv[0], request->svin, 'q', Nullch, 0);
#  endif
#endif
    request->bound = TRUE;
}

static void
populate_env(envp, hv)
char **envp;
HV *hv;
{
    int i;
    char *p, *p1;
    SV   *sv;
    dTHX;

    hv_clear(hv);
    for(i = 0; ; i++) {
	if((p = envp[i]) == NULL) {
	    break;
	}
	p1 = strchr(p, '=');
	assert(p1 != NULL);
	sv = newSVpv(p1 + 1, 0);
	/* call magic for this value ourselves */
	hv_store(hv, p, p1 - p, sv, 0);
	SvSETMAGIC(sv);
    }
}

static int
FCGI_IsFastCGI(FCGP_Request* request)
{
    static int isCGI = -1; /* -1: not checked; 0: FCGI; 1: CGI */

    if (request->requestPtr->listen_sock == FCGI_LISTENSOCK_FILENO) {
	if (isCGI == -1)
	    isCGI = FCGX_IsCGI();
	return !isCGI;
    }

    /* A explicit socket is being used -> assume FastCGI */
    return 1;
}

static int 
FCGI_Accept(FCGP_Request* request)
{
    dTHX;

    if (!FCGI_IsFastCGI(request)) {
	static int been_here = 0;

        /*
         * Not first call to FCGI_Accept and running as CGI means
         * application is done.
         */
	if (been_here)
	    return EOF;

	been_here = 1;
    } else {
#ifdef USE_SFIO
	int i;
#endif
	FCGX_Request *fcgx_req = request->requestPtr;
        int acceptResult;

	FCGI_Finish(request);
#if defined(USE_LOCKING) && defined(USE_THREADS)
	MUTEX_LOCK(&accept_mutex);
#endif
	acceptResult = FCGX_Accept_r(fcgx_req);
#if defined(USE_LOCKING) && defined(USE_THREADS)
	MUTEX_UNLOCK(&accept_mutex);
#endif
        if(acceptResult < 0) {
            return acceptResult;
        }

	populate_env(fcgx_req->envp, request->hvEnv);

#ifdef USE_SFIO
	for (i = 0; i < 3; ++i) {
	    request->io[i] = GvIOn(request->gv[i]);
	    if (!(i == 0 ? IoIFP(request->io[i]) 
			 : IoOFP(request->io[i]))) {
		IoIFP(request->io[i]) = sftmp(0);
		/*IoIFP(request->io[i]) = sfnew(NULL, NULL, SF_UNBOUND, 0, 
				     SF_STRING | (i ? SF_WRITE : SF_READ));*/
		if (i != 0) 
		    IoOFP(request->io[i]) = IoIFP(request->io[i]);
		request->sfcreated[i] = TRUE;
	    }
	}
#else
	if (!request->svout) {
	    newSVrv(request->svout = newSV(0), "FCGI::Stream");
	    newSVrv(request->sverr = newSV(0), "FCGI::Stream");
	    newSVrv(request->svin = newSV(0), "FCGI::Stream");
	}
	sv_setiv(SvRV(request->svout), INT2PTR(IV, fcgx_req->out));
	sv_setiv(SvRV(request->sverr), INT2PTR(IV, fcgx_req->err));
	sv_setiv(SvRV(request->svin), INT2PTR(IV, fcgx_req->in));
#endif
	FCGI_Bind(request);
	request->accepted = TRUE;
    }
    return 0;
}

static void 
FCGI_Finish(FCGP_Request* request)
{
#ifdef USE_SFIO
    int i;
#endif
    int was_bound;
    dTHX;

    if(!request->accepted) {
	return;
    }

    if (was_bound = request->bound) {
	FCGI_UndoBinding(request);
    }
#ifdef USE_SFIO
    for (i = 0; i < 3; ++i) {
	if (request->sfcreated[i]) {
	    sfclose(IoIFP(request->io[i]));
	    IoIFP(request->io[i]) = IoOFP(request->io[i]) = Nullfp;
	    request->sfcreated[i] = FALSE;
	}
    }
#endif
    if (was_bound)
	FCGX_Finish_r(request->requestPtr);
    else
	FCGX_Free(request->requestPtr, 1);
    request->accepted = FALSE;
}

static int 
FCGI_StartFilterData(FCGP_Request* request)
{
    return request->requestPtr->in ? 
	    FCGX_StartFilterData(request->requestPtr->in) : -1;
}

static FCGP_Request *
FCGI_Request(in, out, err, env, socket, flags)
    GV*	    in;
    GV*	    out;
    GV*	    err;
    HV*	    env;
    int	    socket;
    int	    flags;
{
    FCGX_Request* fcgx_req;
    FCGP_Request* req;

    Newz(551, fcgx_req, 1, FCGX_Request);
    FCGX_InitRequest(fcgx_req, socket, flags);
    Newz(551, req, 1, FCGP_Request);
    req->requestPtr = fcgx_req;
    SvREFCNT_inc(in);
    req->gv[0] = in;
    SvREFCNT_inc(out);
    req->gv[1] = out;
    SvREFCNT_inc(err);
    req->gv[2] = err;
    SvREFCNT_inc(env);
    req->hvEnv = env;

    return req;
}

static void
FCGI_Release_Request(FCGP_Request *req)
{
    SvREFCNT_dec(req->gv[0]);
    SvREFCNT_dec(req->gv[1]);
    SvREFCNT_dec(req->gv[2]);
    SvREFCNT_dec(req->hvEnv);
    FCGI_Finish(req);
    Safefree(req->requestPtr);
    Safefree(req);
}

static void
FCGI_Init()
{
#if defined(USE_LOCKING) && defined(USE_THREADS)
    dTHX;

    MUTEX_INIT(&accept_mutex);
#endif

    FCGX_Init();
}

typedef FCGX_Stream *	FCGI__Stream;
typedef FCGP_Request *	FCGI;
typedef	GV*		GLOBREF;
typedef	HV*		HASHREF;

#line 387 "FCGI.c"
XS(XS_FCGI_RequestX); /* prototype to pass -Wmissing-prototypes */
XS(XS_FCGI_RequestX)
{
    dXSARGS;
    if (items != 6)
	Perl_croak(aTHX_ "Usage: FCGI::RequestX(in, out, err, env, socket, flags)");
    {
	GLOBREF	in;
	GLOBREF	out;
	GLOBREF	err;
	HASHREF	env;
	int	socket = (int)SvIV(ST(4));
	int	flags = (int)SvIV(ST(5));
	SV *	RETVAL;

    if (SvROK(ST(0)) && isGV(SvRV(ST(0)))) {
	in = (GV*)SvRV(ST(0));
    } else
	croak("in is not a GLOB reference");

    if (SvROK(ST(1)) && isGV(SvRV(ST(1)))) {
	out = (GV*)SvRV(ST(1));
    } else
	croak("out is not a GLOB reference");

    if (SvROK(ST(2)) && isGV(SvRV(ST(2)))) {
	err = (GV*)SvRV(ST(2));
    } else
	croak("err is not a GLOB reference");

    if (SvROK(ST(3)) && SvTYPE(SvRV(ST(3))) == SVt_PVHV) {
	env = (HV*)SvRV(ST(3));
    } else
	croak("env is not a reference to a hash");
#line 393 "FCGI.xs"
    RETVAL = sv_setref_pv(newSV(0), "FCGI", 
		FCGI_Request(in, out, err, env, socket, flags));

#line 426 "FCGI.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

XS(XS_FCGI_OpenSocket); /* prototype to pass -Wmissing-prototypes */
XS(XS_FCGI_OpenSocket)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: FCGI::OpenSocket(path, backlog)");
    {
	char*	path = (char *)SvPV_nolen(ST(0));
	int	backlog = (int)SvIV(ST(1));
	int	RETVAL;
	dXSTARG;
#line 406 "FCGI.xs"
    RETVAL = FCGX_OpenSocket(path, backlog);
#line 446 "FCGI.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_FCGI_CloseSocket); /* prototype to pass -Wmissing-prototypes */
XS(XS_FCGI_CloseSocket)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: FCGI::CloseSocket(socket)");
    {
	int	socket = (int)SvIV(ST(0));
#line 416 "FCGI.xs"
    close(socket);
#line 462 "FCGI.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_FCGI_Accept); /* prototype to pass -Wmissing-prototypes */
XS(XS_FCGI_Accept)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: FCGI::Accept(request)");
    {
	FCGI	request;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "FCGI")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    request = INT2PTR(FCGI,tmp);
	}
	else
	    Perl_croak(aTHX_ "request is not of type FCGI");

	RETVAL = FCGI_Accept(request);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_FCGI_Finish); /* prototype to pass -Wmissing-prototypes */
XS(XS_FCGI_Finish)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: FCGI::Finish(request)");
    {
	FCGI	request;

	if (sv_derived_from(ST(0), "FCGI")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    request = INT2PTR(FCGI,tmp);
	}
	else
	    Perl_croak(aTHX_ "request is not of type FCGI");

	FCGI_Finish(request);
    }
    XSRETURN_EMPTY;
}

XS(XS_FCGI_Flush); /* prototype to pass -Wmissing-prototypes */
XS(XS_FCGI_Flush)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: FCGI::Flush(request)");
    {
	FCGI	request;

	if (sv_derived_from(ST(0), "FCGI")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    request = INT2PTR(FCGI,tmp);
	}
	else
	    Perl_croak(aTHX_ "request is not of type FCGI");

	FCGI_Flush(request);
    }
    XSRETURN_EMPTY;
}

XS(XS_FCGI_GetEnvironment); /* prototype to pass -Wmissing-prototypes */
XS(XS_FCGI_GetEnvironment)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: FCGI::GetEnvironment(request)");
    {
	FCGI	request;
	HV *	RETVAL;

	if (sv_derived_from(ST(0), "FCGI")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    request = INT2PTR(FCGI,tmp);
	}
	else
	    Perl_croak(aTHX_ "request is not of type FCGI");
#line 444 "FCGI.xs"
    RETVAL = request->hvEnv;

#line 552 "FCGI.c"
	ST(0) = newRV((SV*)RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

XS(XS_FCGI_GetHandles); /* prototype to pass -Wmissing-prototypes */
XS(XS_FCGI_GetHandles)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: FCGI::GetHandles(request)");
    SP -= items;
    {
	FCGI	request;
#line 456 "FCGI.xs"
    int	    i;

#line 571 "FCGI.c"

	if (sv_derived_from(ST(0), "FCGI")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    request = INT2PTR(FCGI,tmp);
	}
	else
	    Perl_croak(aTHX_ "request is not of type FCGI");
#line 459 "FCGI.xs"
    EXTEND(sp,3);
    for (i = 0; i < 3; ++i)
	PUSHs(sv_2mortal(newRV((SV *) request->gv[i])));
#line 583 "FCGI.c"
	PUTBACK;
	return;
    }
}

XS(XS_FCGI_IsFastCGI); /* prototype to pass -Wmissing-prototypes */
XS(XS_FCGI_IsFastCGI)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: FCGI::IsFastCGI(request)");
    {
	FCGI	request;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "FCGI")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    request = INT2PTR(FCGI,tmp);
	}
	else
	    Perl_croak(aTHX_ "request is not of type FCGI");

	RETVAL = FCGI_IsFastCGI(request);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_FCGI_Detach); /* prototype to pass -Wmissing-prototypes */
XS(XS_FCGI_Detach)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: FCGI::Detach(request)");
    {
	FCGI	request;

	if (sv_derived_from(ST(0), "FCGI")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    request = INT2PTR(FCGI,tmp);
	}
	else
	    Perl_croak(aTHX_ "request is not of type FCGI");
#line 476 "FCGI.xs"
    if (request->accepted && request->bound)
	FCGI_UndoBinding(request);
#line 631 "FCGI.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_FCGI_Attach); /* prototype to pass -Wmissing-prototypes */
XS(XS_FCGI_Attach)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: FCGI::Attach(request)");
    {
	FCGI	request;

	if (sv_derived_from(ST(0), "FCGI")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    request = INT2PTR(FCGI,tmp);
	}
	else
	    Perl_croak(aTHX_ "request is not of type FCGI");
#line 486 "FCGI.xs"
    if (request->accepted && !request->bound)
	FCGI_Bind(request);
#line 654 "FCGI.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_FCGI_LastCall); /* prototype to pass -Wmissing-prototypes */
XS(XS_FCGI_LastCall)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: FCGI::LastCall(request)");
    {
	FCGI	request;

	if (sv_derived_from(ST(0), "FCGI")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    request = INT2PTR(FCGI,tmp);
	}
	else
	    Perl_croak(aTHX_ "request is not of type FCGI");
#line 496 "FCGI.xs"
    FCGX_ShutdownPending();
#line 676 "FCGI.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_FCGI_StartFilterData); /* prototype to pass -Wmissing-prototypes */
XS(XS_FCGI_StartFilterData)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: FCGI::StartFilterData(request)");
    {
	FCGI	request;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "FCGI")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    request = INT2PTR(FCGI,tmp);
	}
	else
	    Perl_croak(aTHX_ "request is not of type FCGI");

	RETVAL = FCGI_StartFilterData(request);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_FCGI_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS(XS_FCGI_DESTROY)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: FCGI::DESTROY(request)");
    {
	FCGI	request;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    request = INT2PTR(FCGI,tmp);
	}
	else
	    Perl_croak(aTHX_ "request is not a reference");
#line 510 "FCGI.xs"
    FCGI_Release_Request(request);
#line 722 "FCGI.c"
    }
    XSRETURN_EMPTY;
}

#ifndef USE_SFIO
#define XSubPPtmpAAAA 1

XS(XS_FCGI__Stream_PRINT); /* prototype to pass -Wmissing-prototypes */
XS(XS_FCGI__Stream_PRINT)
{
    dXSARGS;
    if (items < 1)
	Perl_croak(aTHX_ "Usage: FCGI::Stream::PRINT(stream, ...)");
    {
	FCGI__Stream	stream;
#line 523 "FCGI.xs"
	int	n;

#line 741 "FCGI.c"

	if (sv_derived_from(ST(0), "FCGI::Stream")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    stream = INT2PTR(FCGI__Stream,tmp);
	}
	else
	    Perl_croak(aTHX_ "stream is not of type FCGI::Stream");
#line 526 "FCGI.xs"
	for (n = 1; n < items; ++n) {
            STRLEN len;
            register char *tmps = (char *)SvPV(ST(n),len);
            FCGX_PutStr(tmps, len, stream);
	}
	if (SvTRUEx(perl_get_sv("|", FALSE))) 
	    FCGX_FFlush(stream);
#line 757 "FCGI.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_FCGI__Stream_WRITE); /* prototype to pass -Wmissing-prototypes */
XS(XS_FCGI__Stream_WRITE)
{
    dXSARGS;
    if (items < 3)
	Perl_croak(aTHX_ "Usage: FCGI::Stream::WRITE(stream, bufsv, len, ...)");
    {
	FCGI__Stream	stream;
	SV *	bufsv = ST(1);
	int	len = (int)SvIV(ST(2));
#line 541 "FCGI.xs"
	int	offset;
	char *	buf;
	STRLEN	blen;
	int	n;

#line 778 "FCGI.c"
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "FCGI::Stream")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    stream = INT2PTR(FCGI__Stream,tmp);
	}
	else
	    Perl_croak(aTHX_ "stream is not of type FCGI::Stream");
#line 547 "FCGI.xs"
	offset = (items == 4) ? (int)SvIV(ST(3)) : 0;
	buf = SvPV(bufsv, blen);
	if (offset < 0) offset += blen;
	if (len > blen - offset)
	    len = blen - offset;
	if (offset < 0 || offset >= blen ||
		(n = FCGX_PutStr(buf+offset, len, stream)) < 0) 
	    ST(0) = &PL_sv_undef;
	else {
	    ST(0) = sv_newmortal();
	    sv_setpvf(ST(0), "%c", n);
	}
#line 801 "FCGI.c"
    }
    XSRETURN(1);
}

XS(XS_FCGI__Stream_READ); /* prototype to pass -Wmissing-prototypes */
XS(XS_FCGI__Stream_READ)
{
    dXSARGS;
    if (items < 3)
	Perl_croak(aTHX_ "Usage: FCGI::Stream::READ(stream, bufsv, len, ...)");
    {
	FCGI__Stream	stream;
	SV *	bufsv = ST(1);
	int	len = (int)SvIV(ST(2));
#line 567 "FCGI.xs"
	int	offset;
	char *	buf;

#line 820 "FCGI.c"
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "FCGI::Stream")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    stream = INT2PTR(FCGI__Stream,tmp);
	}
	else
	    Perl_croak(aTHX_ "stream is not of type FCGI::Stream");
#line 571 "FCGI.xs"
	offset = (items == 4) ? (int)SvIV(ST(3)) : 0;
	if (! SvOK(bufsv))
	    sv_setpvn(bufsv, "", 0);
	buf = SvGROW(bufsv, len+offset+1);
	len = FCGX_GetStr(buf+offset, len, stream);
	SvCUR_set(bufsv, len+offset);
	*SvEND(bufsv) = '\0';
	(void)SvPOK_only(bufsv);
	SvSETMAGIC(bufsv);
	RETVAL = len;

#line 842 "FCGI.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_FCGI__Stream_GETC); /* prototype to pass -Wmissing-prototypes */
XS(XS_FCGI__Stream_GETC)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: FCGI::Stream::GETC(stream)");
    {
	FCGI__Stream	stream;
#line 590 "FCGI.xs"
	int	retval;

#line 859 "FCGI.c"
	SV *	RETVAL;

	if (sv_derived_from(ST(0), "FCGI::Stream")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    stream = INT2PTR(FCGI__Stream,tmp);
	}
	else
	    Perl_croak(aTHX_ "stream is not of type FCGI::Stream");
#line 593 "FCGI.xs"
	if ((retval = FCGX_GetChar(stream)) != -1) {
	    ST(0) = sv_newmortal();
	    sv_setpvf(ST(0), "%c", retval);
	} else ST(0) = &PL_sv_undef;
#line 873 "FCGI.c"
    }
    XSRETURN(1);
}

XS(XS_FCGI__Stream_CLOSE); /* prototype to pass -Wmissing-prototypes */
XS(XS_FCGI__Stream_CLOSE)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: FCGI::Stream::CLOSE(stream)");
    {
	FCGI__Stream	stream;
	bool	RETVAL;

	if (sv_derived_from(ST(0), "FCGI::Stream")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    stream = INT2PTR(FCGI__Stream,tmp);
	}
	else
	    Perl_croak(aTHX_ "stream is not of type FCGI::Stream");
#line 606 "FCGI.xs"
	RETVAL = FCGX_FClose(stream) != -1;

#line 897 "FCGI.c"
	ST(0) = boolSV(RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

#endif
#ifdef __cplusplus
extern "C"
#endif
XS(boot_FCGI); /* prototype to pass -Wmissing-prototypes */
XS(boot_FCGI)
{
    dXSARGS;
    char* file = __FILE__;

    XS_VERSION_BOOTCHECK ;

        newXSproto("FCGI::RequestX", XS_FCGI_RequestX, file, "***$$$");
        newXSproto("FCGI::OpenSocket", XS_FCGI_OpenSocket, file, "$$");
        newXSproto("FCGI::CloseSocket", XS_FCGI_CloseSocket, file, "$");
        newXSproto("FCGI::Accept", XS_FCGI_Accept, file, "$");
        newXSproto("FCGI::Finish", XS_FCGI_Finish, file, "$");
        newXSproto("FCGI::Flush", XS_FCGI_Flush, file, "$");
        newXSproto("FCGI::GetEnvironment", XS_FCGI_GetEnvironment, file, "$");
        newXSproto("FCGI::GetHandles", XS_FCGI_GetHandles, file, "$");
        newXSproto("FCGI::IsFastCGI", XS_FCGI_IsFastCGI, file, "$");
        newXSproto("FCGI::Detach", XS_FCGI_Detach, file, "$");
        newXSproto("FCGI::Attach", XS_FCGI_Attach, file, "$");
        newXSproto("FCGI::LastCall", XS_FCGI_LastCall, file, "$");
        newXSproto("FCGI::StartFilterData", XS_FCGI_StartFilterData, file, "$");
        newXS("FCGI::DESTROY", XS_FCGI_DESTROY, file);
#if XSubPPtmpAAAA
        newXS("FCGI::Stream::PRINT", XS_FCGI__Stream_PRINT, file);
        newXS("FCGI::Stream::WRITE", XS_FCGI__Stream_WRITE, file);
        newXS("FCGI::Stream::READ", XS_FCGI__Stream_READ, file);
        newXS("FCGI::Stream::GETC", XS_FCGI__Stream_GETC, file);
        newXS("FCGI::Stream::CLOSE", XS_FCGI__Stream_CLOSE, file);
#endif

    /* Initialisation Section */

#line 380 "FCGI.xs"
    FCGI_Init();

#if XSubPPtmpAAAA
#endif
#line 945 "FCGI.c"

    /* End of Initialisation Section */

    XSRETURN_YES;
}

