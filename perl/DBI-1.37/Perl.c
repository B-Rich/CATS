/*
 * This file was generated automatically by xsubpp version 1.9508 from the
 * contents of Perl.xs. Do not edit this file, edit Perl.xs instead.
 *
 *	ANY CHANGES MADE HERE WILL BE LOST!
 *
 */

#line 1 "Perl.xs"
#include "DBIXS.h"
#include "dbd_xsh.h"

struct imp_drh_st {
    dbih_drc_t com;     /* MUST be first element in structure   */
};
struct imp_dbh_st {
    dbih_dbc_t com;     /* MUST be first element in structure   */
};
struct imp_sth_st {
    dbih_stc_t com;     /* MUST be first element in structure   */
};


DBISTATE_DECLARE;

#line 27 "Perl.c"

/* INCLUDE:  Including 'Perl.xsi' from 'Perl.xs' */

#include "Driver_xst.h"
#ifdef dbd_discon_all
#define XSubPPtmpAAAA 1

XS(XS_DBD__Perl__dr_discon_all_); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Perl__dr_discon_all_)
{
    dXSARGS;
    dXSI32;
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(drh)", GvNAME(CvGV(cv)));
    {
	SV *	drh = ST(0);
#line 42 "Perl.xsi"
    D_imp_drh(drh);
    if (0) ix = ix;	/* avoid unused variable warning */
    ST(0) = dbd_discon_all(drh, imp_drh) ? &sv_yes : &sv_no;
#line 48 "Perl.c"
    }
    XSRETURN(1);
}

#endif /* dbd_discon_all */
#ifdef dbd_dr_data_sources
#define XSubPPtmpAAAB 1

XS(XS_DBD__Perl__dr_data_sources); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Perl__dr_data_sources)
{
    dXSARGS;
    if (items < 1 || items > 2)
	Perl_croak(aTHX_ "Usage: DBD::Perl::dr::data_sources(drh, attr = Nullsv)");
    SP -= items;
    {
	SV *	drh = ST(0);
	SV *	attr;

	if (items < 2)
	    attr = Nullsv;
	else {
	    attr = ST(1);
	}
#line 56 "Perl.xsi"
    {
	D_imp_drh(drh);
	AV *av = dbd_dr_data_sources(drh, imp_drh, attr);
	if (av) {
	    int i;
	    int n = AvFILL(av)+1;
	    EXTEND(sp, n);
	    for (i = 0; i < n; ++i) {
		PUSHs(AvARRAY(av)[i]);
	    }
	}
    }
#line 86 "Perl.c"
	PUTBACK;
	return;
    }
}

#endif
XS(XS_DBD__Perl__db__login); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Perl__db__login)
{
    dXSARGS;
    if (items < 4 || items > 5)
	Perl_croak(aTHX_ "Usage: DBD::Perl::db::_login(dbh, dbname, username, password, attribs=Nullsv)");
    {
	SV *	dbh = ST(0);
	char *	dbname = (char *)SvPV_nolen(ST(1));
	SV *	username = ST(2);
	SV *	password = ST(3);
	SV *	attribs;

	if (items < 5)
	    attribs = Nullsv;
	else {
	    attribs = ST(4);
	}
#line 86 "Perl.xsi"
    {
    STRLEN lna;
    D_imp_dbh(dbh);
    char *u = (SvOK(username)) ? SvPV(username,lna) : "";
    char *p = (SvOK(password)) ? SvPV(password,lna) : "";
#ifdef dbd_db_login6
    ST(0) = dbd_db_login6(dbh, imp_dbh, dbname, u, p, attribs) ? &sv_yes : &sv_no;
#else
    ST(0) = dbd_db_login( dbh, imp_dbh, dbname, u, p) ? &sv_yes : &sv_no;
#endif
    }
#line 123 "Perl.c"
    }
    XSRETURN(1);
}

XS(XS_DBD__Perl__db_selectall_arrayref); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Perl__db_selectall_arrayref)
{
    dXSARGS;
    {
#line 102 "Perl.xsi"
    SV *sth;
    SV **maxrows_svp;
    SV **tmp_svp;
    SV *attr = &PL_sv_undef;
    imp_sth_t *imp_sth;
#line 139 "Perl.c"
#line 108 "Perl.xsi"
    if (items > 2) {
	attr = ST(2);
	if (SvROK(attr) &&
		(DBD_ATTRIB_TRUE(attr,"Slice",5,tmp_svp) || DBD_ATTRIB_TRUE(attr,"Columns",7,tmp_svp))
	) {
	    /* fallback to perl implementation */
	    ST(0) = dbixst_bounce_method("DBD::Perl::db::SUPER::selectall_arrayref", items);
	    XSRETURN(1);
	}
    }
    /* --- prepare --- */
    if (SvROK(ST(1))) {
	sth = ST(1);
    }
    else {
	sth = dbixst_bounce_method("prepare", 3);
	if (!SvROK(sth))
	    XSRETURN_UNDEF;
    }
    imp_sth = (imp_sth_t*)(DBIh_COM(sth));
    /* --- bind_param --- */
    if (items > 3) {    /* need to bind params before execute */
        if (!dbdxst_bind_params(sth, imp_sth, items-2, ax+2) ) {
            XSRETURN_UNDEF;
        }
    }
    /* --- execute --- */
    DBIc_ROW_COUNT(imp_sth) = 0;
    if ( dbd_st_execute(sth, imp_sth) <= -2 ) { /* -2 == error */
        XSRETURN_UNDEF;
    }
    /* --- fetchall --- */
    maxrows_svp = DBD_ATTRIB_GET_SVP(attr, "MaxRows", 7);
    ST(0) = dbdxst_fetchall_arrayref(sth, &PL_sv_undef, (maxrows_svp) ? *maxrows_svp : &PL_sv_undef);
#line 175 "Perl.c"
    }
    XSRETURN(1);
}

XS(XS_DBD__Perl__db_selectrow_arrayref); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Perl__db_selectrow_arrayref)
{
    dXSARGS;
    dXSI32;
   PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 149 "Perl.xsi"
    imp_sth_t *imp_sth;
    SV *sth;
    AV *row_av;
#line 192 "Perl.c"
#line 153 "Perl.xsi"
    if (SvROK(ST(1))) {
	sth = ST(1);
    }
    else {
	/* --- prepare --- */
	sth = dbixst_bounce_method("prepare", 3);
	if (!SvROK(sth))
	    XSRETURN_UNDEF;
    }
    imp_sth = (imp_sth_t*)(DBIh_COM(sth));
    /* --- bind_param --- */
    if (items > 3) {	/* need to bind params before execute */
	if (!dbdxst_bind_params(sth, imp_sth, items-2, ax+2) ) {
	    XSRETURN_UNDEF;
	}
    }
    /* --- execute --- */
    DBIc_ROW_COUNT(imp_sth) = 0;
    if ( dbd_st_execute(sth, imp_sth) <= -2 ) {	/* -2 == error */
        XSRETURN_UNDEF;
    }
    /* --- fetchrow_arrayref --- */
    row_av = dbd_st_fetch(sth, imp_sth);
    if (!row_av) {
	if (GIMME == G_SCALAR)
	    PUSHs(&PL_sv_undef);
    }
    else if (ix == 1) { /* selectrow_array */
	int i;
	int num_fields = AvFILL(row_av)+1;
	if (GIMME == G_SCALAR)
	    num_fields = 1; /* return just first field */
	EXTEND(sp, num_fields);
	for(i=0; i < num_fields; ++i) {
	    PUSHs(AvARRAY(row_av)[i]);
	}
    }
    else {
	PUSHs( sv_2mortal(newRV((SV *)row_av)) );
    }
    /* --- finish --- */
#ifdef dbd_st_finish3
    dbd_st_finish3(sth, imp_sth, 0);
#else
    dbd_st_finish(sth, imp_sth);
#endif
#line 240 "Perl.c"
	PUTBACK;
	return;
    }
}

#ifdef dbd_db_do4 /* deebeedee-deebee-doo, deebee-doobee-dah? */
#define XSubPPtmpAAAC 1

XS(XS_DBD__Perl__db_do); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Perl__db_do)
{
    dXSARGS;
    if (items < 2 || items > 3)
	Perl_croak(aTHX_ "Usage: DBD::Perl::db::do(dbh, statement, params = Nullsv)");
    {
	SV *	dbh = ST(0);
	char *	statement = (char *)SvPV_nolen(ST(1));
	SV *	params;

	if (items < 3)
	    params = Nullsv;
	else {
	    params = ST(2);
	}
#line 209 "Perl.xsi"
    D_imp_dbh(dbh);
    ST(0) = dbd_db_do4(dbh, imp_dbh, statement, params) ? &sv_yes : &sv_no;
#line 268 "Perl.c"
    }
    XSRETURN(1);
}

#endif
XS(XS_DBD__Perl__db_commit); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Perl__db_commit)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: DBD::Perl::db::commit(dbh)");
    {
	SV *	dbh = ST(0);
#line 219 "Perl.xsi"
    D_imp_dbh(dbh);
    if (DBIc_has(imp_dbh,DBIcf_AutoCommit) && DBIc_WARN(imp_dbh))
	warn("commit ineffective with AutoCommit enabled");
    ST(0) = dbd_db_commit(dbh, imp_dbh) ? &sv_yes : &sv_no;
#line 287 "Perl.c"
    }
    XSRETURN(1);
}

XS(XS_DBD__Perl__db_rollback); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Perl__db_rollback)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: DBD::Perl::db::rollback(dbh)");
    {
	SV *	dbh = ST(0);
#line 229 "Perl.xsi"
    D_imp_dbh(dbh);
    if (DBIc_has(imp_dbh,DBIcf_AutoCommit) && DBIc_WARN(imp_dbh))
	warn("rollback ineffective with AutoCommit enabled");
    ST(0) = dbd_db_rollback(dbh, imp_dbh) ? &sv_yes : &sv_no;
#line 305 "Perl.c"
    }
    XSRETURN(1);
}

XS(XS_DBD__Perl__db_disconnect); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Perl__db_disconnect)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: DBD::Perl::db::disconnect(dbh)");
    {
	SV *	dbh = ST(0);
#line 239 "Perl.xsi"
    D_imp_dbh(dbh);
    if ( !DBIc_ACTIVE(imp_dbh) ) {
	XSRETURN_YES;
    }
    /* pre-disconnect checks and tidy-ups */
    if (DBIc_CACHED_KIDS(imp_dbh)) {
	SvREFCNT_dec(DBIc_CACHED_KIDS(imp_dbh));      /* cast them to the winds	*/
	DBIc_CACHED_KIDS(imp_dbh) = Nullhv;
    }
    /* Check for disconnect() being called whilst refs to cursors	*/
    /* still exists. This possibly needs some more thought.		*/
    if (DBIc_ACTIVE_KIDS(imp_dbh) && DBIc_WARN(imp_dbh) && !dirty) {
	STRLEN lna;
	char *plural = (DBIc_ACTIVE_KIDS(imp_dbh)==1) ? "" : "s";
	warn("%s->disconnect invalidates %d active statement handle%s %s",
	    SvPV(dbh,lna), (int)DBIc_ACTIVE_KIDS(imp_dbh), plural,
	    "(either destroy statement handles or call finish on them before disconnecting)");
    }
    ST(0) = dbd_db_disconnect(dbh, imp_dbh) ? &sv_yes : &sv_no;
    DBIc_ACTIVE_off(imp_dbh);	/* ensure it's off, regardless */
#line 339 "Perl.c"
    }
    XSRETURN(1);
}

XS(XS_DBD__Perl__db_STORE); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Perl__db_STORE)
{
    dXSARGS;
    if (items != 3)
	Perl_croak(aTHX_ "Usage: DBD::Perl::db::STORE(dbh, keysv, valuesv)");
    {
	SV *	dbh = ST(0);
	SV *	keysv = ST(1);
	SV *	valuesv = ST(2);
#line 267 "Perl.xsi"
    D_imp_dbh(dbh);
    if (SvGMAGICAL(valuesv))
	mg_get(valuesv);
    ST(0) = &sv_yes;
    if (!dbd_db_STORE_attrib(dbh, imp_dbh, keysv, valuesv))
	if (!DBIc_DBISTATE(imp_dbh)->set_attr(dbh, keysv, valuesv))
	    ST(0) = &sv_no;
#line 362 "Perl.c"
    }
    XSRETURN(1);
}

XS(XS_DBD__Perl__db_FETCH); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Perl__db_FETCH)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: DBD::Perl::db::FETCH(dbh, keysv)");
    {
	SV *	dbh = ST(0);
	SV *	keysv = ST(1);
#line 281 "Perl.xsi"
    D_imp_dbh(dbh);
    SV *valuesv = dbd_db_FETCH_attrib(dbh, imp_dbh, keysv);
    if (!valuesv)
	valuesv = DBIc_DBISTATE(imp_dbh)->get_attr(dbh, keysv);
    ST(0) = valuesv;	/* dbd_db_FETCH_attrib did sv_2mortal	*/
#line 382 "Perl.c"
    }
    XSRETURN(1);
}

XS(XS_DBD__Perl__db_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Perl__db_DESTROY)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: DBD::Perl::db::DESTROY(dbh)");
    SP -= items;
    {
	SV *	dbh = ST(0);
#line 292 "Perl.xsi"
    D_imp_dbh(dbh);
    ST(0) = &sv_yes;
    if (!DBIc_IMPSET(imp_dbh)) {	/* was never fully set up	*/
	STRLEN lna;
	if (DBIc_WARN(imp_dbh) && !dirty && DBIc_DBISTATE(imp_dbh)->debug >= 2)
	     PerlIO_printf(DBILOGFP,
		"         DESTROY for %s ignored - handle not initialised\n",
			SvPV(dbh,lna));
    }
    else {
	/* pre-disconnect checks and tidy-ups */
	if (DBIc_CACHED_KIDS(imp_dbh)) {
	    SvREFCNT_dec(DBIc_CACHED_KIDS(imp_dbh));  /* cast them to the winds	*/
	    DBIc_CACHED_KIDS(imp_dbh) = Nullhv;
	}
        if (DBIc_IADESTROY(imp_dbh)) {		  /* want's ineffective destroy	*/
            DBIc_ACTIVE_off(imp_dbh);
        }
	if (DBIc_ACTIVE(imp_dbh)) {
	    /* The application has not explicitly disconnected. That's bad.	*/
	    /* To ensure integrity we *must* issue a rollback. This will be	*/
	    /* harmless	if the application has issued a commit. If it hasn't	*/
	    /* then it'll ensure integrity. Consider a Ctrl-C killing perl	*/
	    /* between two statements that must be executed as a transaction.	*/
	    /* Perl will call DESTROY on the dbh and, if we don't rollback,	*/
	    /* the server may automatically commit! Bham! Corrupt database!	*/
	    if (!DBIc_has(imp_dbh,DBIcf_AutoCommit)) {
		if (DBIc_WARN(imp_dbh) && (!dirty || DBIc_DBISTATE(imp_dbh)->debug >= 3))
		     warn("Issuing rollback() for database handle being DESTROY'd without explicit disconnect()");
		dbd_db_rollback(dbh, imp_dbh);			/* ROLLBACK! */
	    }
	    dbd_db_disconnect(dbh, imp_dbh);
	    DBIc_ACTIVE_off(imp_dbh);	/* ensure it's off, regardless */
	}
	dbd_db_destroy(dbh, imp_dbh);
    }
#line 433 "Perl.c"
	PUTBACK;
	return;
    }
}

#ifdef dbd_take_imp_data
#define XSubPPtmpAAAD 1

XS(XS_DBD__Perl__db_dbd_take_imp_data); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Perl__db_dbd_take_imp_data)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: DBD::Perl::db::dbd_take_imp_data(h)");
    {
	SV *	h = ST(0);
#line 336 "Perl.xsi"
    D_imp_xxh(h);
    ST(0) = (dbd_take_imp_data(h, imp_xxh, NULL))
	? dbixst_bounce_method("DBD::Perl::db::SUPER::take_imp_data", items)
	: &sv_undef;
#line 455 "Perl.c"
    }
    XSRETURN(1);
}

#endif
XS(XS_DBD__Perl__st__prepare); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Perl__st__prepare)
{
    dXSARGS;
    if (items < 2 || items > 3)
	Perl_croak(aTHX_ "Usage: DBD::Perl::st::_prepare(sth, statement, attribs=Nullsv)");
    {
	SV *	sth = ST(0);
	char *	statement = (char *)SvPV_nolen(ST(1));
	SV *	attribs;

	if (items < 3)
	    attribs = Nullsv;
	else {
	    attribs = ST(2);
	}
#line 357 "Perl.xsi"
    {
    D_imp_sth(sth);
    DBD_ATTRIBS_CHECK("_prepare", sth, attribs);
    ST(0) = dbd_st_prepare(sth, imp_sth, statement, attribs) ? &sv_yes : &sv_no;
    }
#line 483 "Perl.c"
    }
    XSRETURN(1);
}

#ifdef dbd_st_rows
#define XSubPPtmpAAAE 1

XS(XS_DBD__Perl__st_rows); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Perl__st_rows)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: DBD::Perl::st::rows(sth)");
    {
	SV *	sth = ST(0);
#line 370 "Perl.xsi"
    D_imp_sth(sth);
    XST_mIV(0, dbd_st_rows(sth, imp_sth));
#line 502 "Perl.c"
    }
    XSRETURN(1);
}

#endif /* dbd_st_rows */
XS(XS_DBD__Perl__st_bind_param); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Perl__st_bind_param)
{
    dXSARGS;
    if (items < 3 || items > 4)
	Perl_croak(aTHX_ "Usage: DBD::Perl::st::bind_param(sth, param, value, attribs=Nullsv)");
    {
	SV *	sth = ST(0);
	SV *	param = ST(1);
	SV *	value = ST(2);
	SV *	attribs;

	if (items < 4)
	    attribs = Nullsv;
	else {
	    attribs = ST(3);
	}
#line 383 "Perl.xsi"
    {
    IV sql_type = 0;
    D_imp_sth(sth);
    if (SvGMAGICAL(value))
	mg_get(value);
    if (attribs) {
	if (SvNIOK(attribs)) {
	    sql_type = SvIV(attribs);
	    attribs = Nullsv;
	}
	else {
	    SV **svp;
	    DBD_ATTRIBS_CHECK("bind_param", sth, attribs);
	    /* XXX we should perhaps complain if TYPE is not SvNIOK */
	    DBD_ATTRIB_GET_IV(attribs, "TYPE",4, svp, sql_type);
	}
    }
    ST(0) = dbd_bind_ph(sth, imp_sth, param, value, sql_type, attribs, FALSE, 0)
		? &sv_yes : &sv_no;
    }
#line 546 "Perl.c"
    }
    XSRETURN(1);
}

XS(XS_DBD__Perl__st_bind_param_inout); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Perl__st_bind_param_inout)
{
    dXSARGS;
    if (items < 4 || items > 5)
	Perl_croak(aTHX_ "Usage: DBD::Perl::st::bind_param_inout(sth, param, value_ref, maxlen, attribs=Nullsv)");
    {
	SV *	sth = ST(0);
	SV *	param = ST(1);
	SV *	value_ref = ST(2);
	IV	maxlen = (IV)SvIV(ST(3));
	SV *	attribs;

	if (items < 5)
	    attribs = Nullsv;
	else {
	    attribs = ST(4);
	}
#line 413 "Perl.xsi"
    {
    IV sql_type = 0;
    D_imp_sth(sth);
    SV *value;
    if (!SvROK(value_ref) || SvTYPE(SvRV(value_ref)) > SVt_PVMG)
	croak("bind_param_inout needs a reference to a scalar value");
    value = SvRV(value_ref);
    if (SvREADONLY(value))
	croak("Modification of a read-only value attempted");
    if (SvGMAGICAL(value))
	mg_get(value);
    if (attribs) {
	if (SvNIOK(attribs)) {
	    sql_type = SvIV(attribs);
	    attribs = Nullsv;
	}
	else {
	    SV **svp;
	    DBD_ATTRIBS_CHECK("bind_param", sth, attribs);
	    DBD_ATTRIB_GET_IV(attribs, "TYPE",4, svp, sql_type);
	}
    }
    ST(0) = dbd_bind_ph(sth, imp_sth, param, value, sql_type, attribs, TRUE, maxlen)
		? &sv_yes : &sv_no;
    }
#line 595 "Perl.c"
    }
    XSRETURN(1);
}

XS(XS_DBD__Perl__st_execute); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Perl__st_execute)
{
    dXSARGS;
    if (items < 1)
	Perl_croak(aTHX_ "Usage: DBD::Perl::st::execute(sth, ...)");
    {
	SV *	sth = ST(0);
#line 444 "Perl.xsi"
    D_imp_sth(sth);
    int retval;
    if (items > 1) {	/* need to bind params */
	if (!dbdxst_bind_params(sth, imp_sth, items, ax) ) {
	    XSRETURN_UNDEF;
	}
    }
    /* XXX this code is duplicated in selectrow_arrayref above	*/
    if (DBIc_ROW_COUNT(imp_sth) > 0) /* reset for re-execute */
	DBIc_ROW_COUNT(imp_sth) = 0;
    retval = dbd_st_execute(sth, imp_sth);
    /* remember that dbd_st_execute must return <= -2 for error	*/
    if (retval == 0)		/* ok with no rows affected	*/
	XST_mPV(0, "0E0");	/* (true but zero)		*/
    else if (retval < -1)	/* -1 == unknown number of rows	*/
	XST_mUNDEF(0);		/* <= -2 means error   		*/
    else
	XST_mIV(0, retval);	/* typically 1, rowcount or -1	*/
#line 627 "Perl.c"
    }
    XSRETURN(1);
}

XS(XS_DBD__Perl__st_fetchrow_arrayref); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Perl__st_fetchrow_arrayref)
{
    dXSARGS;
    dXSI32;
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(sth)", GvNAME(CvGV(cv)));
    {
	SV *	sth = ST(0);
#line 470 "Perl.xsi"
    D_imp_sth(sth);
    AV *av;
    if (0) ix = ix;	/* avoid unused variable warning */
    av = dbd_st_fetch(sth, imp_sth);
    ST(0) = (av) ? sv_2mortal(newRV((SV *)av)) : &PL_sv_undef;
#line 647 "Perl.c"
    }
    XSRETURN(1);
}

XS(XS_DBD__Perl__st_fetchrow_array); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Perl__st_fetchrow_array)
{
    dXSARGS;
    dXSI32;
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(sth)", GvNAME(CvGV(cv)));
    SP -= items;
    {
	SV *	sth = ST(0);
#line 483 "Perl.xsi"
    D_imp_sth(sth);
    AV *av;
    av = dbd_st_fetch(sth, imp_sth);
    if (av) {
	int i;
	int num_fields = AvFILL(av)+1;
	EXTEND(sp, num_fields);
	for(i=0; i < num_fields; ++i) {
	    PUSHs(AvARRAY(av)[i]);
	}
	if (0) ix = ix;	/* avoid unused variable warning */
    }
#line 675 "Perl.c"
	PUTBACK;
	return;
    }
}

XS(XS_DBD__Perl__st_fetchall_arrayref); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Perl__st_fetchall_arrayref)
{
    dXSARGS;
    if (items < 1 || items > 3)
	Perl_croak(aTHX_ "Usage: DBD::Perl::st::fetchall_arrayref(sth, slice=&PL_sv_undef, batch_row_count=&PL_sv_undef)");
    {
	SV *	sth = ST(0);
	SV *	slice;
	SV *	batch_row_count;

	if (items < 2)
	    slice = &PL_sv_undef;
	else {
	    slice = ST(1);
	}

	if (items < 3)
	    batch_row_count = &PL_sv_undef;
	else {
	    batch_row_count = ST(2);
	}
#line 503 "Perl.xsi"
    if (SvOK(slice)) {  /* fallback to perl implementation */
        ST(0) = dbixst_bounce_method("DBD::Perl::st::SUPER::fetchall_arrayref", 3);
    }
    else {
	ST(0) = dbdxst_fetchall_arrayref(sth, slice, batch_row_count);
    }
#line 710 "Perl.c"
    }
    XSRETURN(1);
}

XS(XS_DBD__Perl__st_finish); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Perl__st_finish)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: DBD::Perl::st::finish(sth)");
    {
	SV *	sth = ST(0);
#line 515 "Perl.xsi"
    D_imp_sth(sth);
    D_imp_dbh_from_sth;
    if (!DBIc_ACTIVE(imp_sth)) {
	/* No active statement to finish	*/
	XSRETURN_YES;
    }
    if (!DBIc_ACTIVE(imp_dbh)) {
	/* Either an explicit disconnect() or global destruction	*/
	/* has disconnected us from the database. Finish is meaningless	*/
	DBIc_ACTIVE_off(imp_sth);
	XSRETURN_YES;
    }
#ifdef dbd_st_finish3
    ST(0) = dbd_st_finish3(sth, imp_sth, 0) ? &sv_yes : &sv_no;
#else
    ST(0) = dbd_st_finish(sth, imp_sth) ? &sv_yes : &sv_no;
#endif
#line 741 "Perl.c"
    }
    XSRETURN(1);
}

XS(XS_DBD__Perl__st_blob_read); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Perl__st_blob_read)
{
    dXSARGS;
    if (items < 4 || items > 6)
	Perl_croak(aTHX_ "Usage: DBD::Perl::st::blob_read(sth, field, offset, len, destrv=Nullsv, destoffset=0)");
    {
	SV *	sth = ST(0);
	int	field = (int)SvIV(ST(1));
	long	offset = (long)SvIV(ST(2));
	long	len = (long)SvIV(ST(3));
	SV *	destrv;
	long	destoffset;

	if (items < 5)
	    destrv = Nullsv;
	else {
	    destrv = ST(4);
	}

	if (items < 6)
	    destoffset = 0;
	else {
	    destoffset = (long)SvIV(ST(5));
	}
#line 543 "Perl.xsi"
    {
    D_imp_sth(sth);
    if (!destrv)
        destrv = sv_2mortal(newRV(sv_2mortal(newSV(0))));
    if (dbd_st_blob_read(sth, imp_sth, field, offset, len, destrv, destoffset))
         ST(0) = SvRV(destrv);
    else ST(0) = &PL_sv_undef;
    }
#line 780 "Perl.c"
    }
    XSRETURN(1);
}

XS(XS_DBD__Perl__st_STORE); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Perl__st_STORE)
{
    dXSARGS;
    if (items != 3)
	Perl_croak(aTHX_ "Usage: DBD::Perl::st::STORE(sth, keysv, valuesv)");
    {
	SV *	sth = ST(0);
	SV *	keysv = ST(1);
	SV *	valuesv = ST(2);
#line 559 "Perl.xsi"
    D_imp_sth(sth);
    if (SvGMAGICAL(valuesv))
	mg_get(valuesv);
    ST(0) = &sv_yes;
    if (!dbd_st_STORE_attrib(sth, imp_sth, keysv, valuesv))
	if (!DBIc_DBISTATE(imp_sth)->set_attr(sth, keysv, valuesv))
	    ST(0) = &sv_no;
#line 803 "Perl.c"
    }
    XSRETURN(1);
}

XS(XS_DBD__Perl__st_FETCH_attrib); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Perl__st_FETCH_attrib)
{
    dXSARGS;
    dXSI32;
    if (items != 2)
       Perl_croak(aTHX_ "Usage: %s(sth, keysv)", GvNAME(CvGV(cv)));
    {
	SV *	sth = ST(0);
	SV *	keysv = ST(1);
#line 576 "Perl.xsi"
    D_imp_sth(sth);
    SV *valuesv;
    if (0) ix = ix;	/* avoid unused variable warning */
    valuesv = dbd_st_FETCH_attrib(sth, imp_sth, keysv);
    if (!valuesv)
	valuesv = DBIc_DBISTATE(imp_sth)->get_attr(sth, keysv);
    ST(0) = valuesv;	/* dbd_st_FETCH_attrib did sv_2mortal	*/
#line 826 "Perl.c"
    }
    XSRETURN(1);
}

XS(XS_DBD__Perl__st_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Perl__st_DESTROY)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: DBD::Perl::st::DESTROY(sth)");
    SP -= items;
    {
	SV *	sth = ST(0);
#line 589 "Perl.xsi"
    D_imp_sth(sth);
    ST(0) = &sv_yes;
    if (!DBIc_IMPSET(imp_sth)) {	/* was never fully set up	*/
	STRLEN lna;
	if (DBIc_WARN(imp_sth) && !dirty && DBIc_DBISTATE(imp_sth)->debug >= 2)
	     PerlIO_printf(DBILOGFP,
		"Statement handle %s DESTROY ignored - never set up\n",
		    SvPV(sth,lna));
    }
    else {
        if (DBIc_IADESTROY(imp_sth)) { /* want's ineffective destroy    */
            DBIc_ACTIVE_off(imp_sth);
        }
	if (DBIc_ACTIVE(imp_sth)) {
	    D_imp_dbh_from_sth;
	    if (DBIc_ACTIVE(imp_dbh)) {
#ifdef dbd_st_finish3
	    dbd_st_finish3(sth, imp_sth, 1);
#else
	    dbd_st_finish(sth, imp_sth);
#endif
	    }
	    else {
		DBIc_ACTIVE_off(imp_sth);
	    }
	}
	dbd_st_destroy(sth, imp_sth);
    }
#line 869 "Perl.c"
	PUTBACK;
	return;
    }
}


/* INCLUDE: Returning to 'Perl.xs' from 'Perl.xsi' */

#ifdef __cplusplus
extern "C"
#endif
XS(boot_DBD__Perl); /* prototype to pass -Wmissing-prototypes */
XS(boot_DBD__Perl)
{
    dXSARGS;
    char* file = __FILE__;

    XS_VERSION_BOOTCHECK ;

    {
        CV * cv ;

#if XSubPPtmpAAAA
        cv = newXS("DBD::Perl::dr::discon_all_", XS_DBD__Perl__dr_discon_all_, file);
        XSANY.any_i32 = 0 ;
        cv = newXS("DBD::Perl::dr::disconnect_all", XS_DBD__Perl__dr_discon_all_, file);
        XSANY.any_i32 = 1 ;
#endif
#if XSubPPtmpAAAB
        newXS("DBD::Perl::dr::data_sources", XS_DBD__Perl__dr_data_sources, file);
#endif
        newXS("DBD::Perl::db::_login", XS_DBD__Perl__db__login, file);
        newXS("DBD::Perl::db::selectall_arrayref", XS_DBD__Perl__db_selectall_arrayref, file);
        cv = newXS("DBD::Perl::db::selectrow_array", XS_DBD__Perl__db_selectrow_arrayref, file);
        XSANY.any_i32 = 1 ;
        cv = newXS("DBD::Perl::db::selectrow_arrayref", XS_DBD__Perl__db_selectrow_arrayref, file);
        XSANY.any_i32 = 0 ;
#if XSubPPtmpAAAC
        newXS("DBD::Perl::db::do", XS_DBD__Perl__db_do, file);
#endif
        newXS("DBD::Perl::db::commit", XS_DBD__Perl__db_commit, file);
        newXS("DBD::Perl::db::rollback", XS_DBD__Perl__db_rollback, file);
        newXS("DBD::Perl::db::disconnect", XS_DBD__Perl__db_disconnect, file);
        newXS("DBD::Perl::db::STORE", XS_DBD__Perl__db_STORE, file);
        newXS("DBD::Perl::db::FETCH", XS_DBD__Perl__db_FETCH, file);
        newXS("DBD::Perl::db::DESTROY", XS_DBD__Perl__db_DESTROY, file);
#if XSubPPtmpAAAD
        newXS("DBD::Perl::db::dbd_take_imp_data", XS_DBD__Perl__db_dbd_take_imp_data, file);
#endif
        newXS("DBD::Perl::st::_prepare", XS_DBD__Perl__st__prepare, file);
#if XSubPPtmpAAAE
        newXS("DBD::Perl::st::rows", XS_DBD__Perl__st_rows, file);
#endif
        newXS("DBD::Perl::st::bind_param", XS_DBD__Perl__st_bind_param, file);
        newXS("DBD::Perl::st::bind_param_inout", XS_DBD__Perl__st_bind_param_inout, file);
        newXS("DBD::Perl::st::execute", XS_DBD__Perl__st_execute, file);
        cv = newXS("DBD::Perl::st::fetch", XS_DBD__Perl__st_fetchrow_arrayref, file);
        XSANY.any_i32 = 1 ;
        cv = newXS("DBD::Perl::st::fetchrow_arrayref", XS_DBD__Perl__st_fetchrow_arrayref, file);
        XSANY.any_i32 = 0 ;
        cv = newXS("DBD::Perl::st::fetchrow_array", XS_DBD__Perl__st_fetchrow_array, file);
        XSANY.any_i32 = 0 ;
        cv = newXS("DBD::Perl::st::fetchrow", XS_DBD__Perl__st_fetchrow_array, file);
        XSANY.any_i32 = 1 ;
        newXS("DBD::Perl::st::fetchall_arrayref", XS_DBD__Perl__st_fetchall_arrayref, file);
        newXS("DBD::Perl::st::finish", XS_DBD__Perl__st_finish, file);
        newXS("DBD::Perl::st::blob_read", XS_DBD__Perl__st_blob_read, file);
        newXS("DBD::Perl::st::STORE", XS_DBD__Perl__st_STORE, file);
        cv = newXS("DBD::Perl::st::FETCH_attrib", XS_DBD__Perl__st_FETCH_attrib, file);
        XSANY.any_i32 = 0 ;
        cv = newXS("DBD::Perl::st::FETCH", XS_DBD__Perl__st_FETCH_attrib, file);
        XSANY.any_i32 = 1 ;
        newXS("DBD::Perl::st::DESTROY", XS_DBD__Perl__st_DESTROY, file);
    }

    /* Initialisation Section */

#line 18 "Perl.xsi"
    items = 0;  /* avoid 'unused variable' warning */
    DBISTATE_INIT;
    /* XXX this interface will change: */
    DBI_IMP_SIZE("DBD::Perl::dr::imp_data_size", sizeof(imp_drh_t));
    DBI_IMP_SIZE("DBD::Perl::db::imp_data_size", sizeof(imp_dbh_t));
    DBI_IMP_SIZE("DBD::Perl::st::imp_data_size", sizeof(imp_sth_t));
    dbd_init(DBIS);

#if XSubPPtmpAAAA
#endif
#if XSubPPtmpAAAB
#endif
#if XSubPPtmpAAAC
#endif
#if XSubPPtmpAAAD
#endif
#if XSubPPtmpAAAE
#endif
#line 966 "Perl.c"

    /* End of Initialisation Section */

    XSRETURN_YES;
}

